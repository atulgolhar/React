we have App.js
Need to 
create data folder 			data
create new file db.json			db.json

inside db.json
we can add and modify data from within the App component
right now we have a static state for posts 
these are objects inside an array
(ie post data is hard coded inside App.js 
so any changes to posts then reload App will result in 
default hardcoded posts remaining inside App).
Need to make post state dynamic (thus eliminate hardcoding).
We cut hardcoded posts from App.js and paste into db.json file
and need to add quotes some elements.

so here we have an object		{
we have given it the name "posts"	"posts":
key-value so the value for this property is the array		[
notice that each of the json objects are within quotes ""
vs no quotes in the hard coded json data in the App component
therefore you need to ensure that you are formatting like this in db.json v06.04.09
now save b/c we have the db.json file inside the data folder

{
    "posts": [
      {
        "id": 1,							added "" to key
        "title": "My First Post"					added "" to key



OLD 
App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home';
import NewPost from './NewPost';
import PostPage from './PostPage';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';

function App() {
  const [posts, setPosts] = useState([
        {
          id: 1,
          title: "My First Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },
        {
          id: 2,
          title: "My 2nd Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },
        {
          id: 3,
          title: "My 3rd Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },
        {
          id: 4,
          title: "My 4th Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        }
      ])

  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const history = useHistory();

hardcoded posts code here

function App() {
    const [posts, setPosts] = useState([
        {
          id: 1,							missing "" for key
          title: "My First Post"					missing "" for key
          datetime: "July 01, 2023 11:17:36 AM"				missing "" for key
          body: "Lorem ipsum dolor sit amet consectuor elit."		missing "" for key
        },


db.json properly formated posts here
{
    "posts": [
      {
        "id": 1,							added "" to key
        "title": "My First Post"					added "" to key
        "datetime": "July 01, 2023 11:17:36 AM"				added "" to key
        "body": "Lorem ipsum dolor sit amet consectuor elit."		added "" to key
      },

v06.04.18
now we go back to the App.js file
function App() {
  const [posts, setPosts] = useState([
				     ^ from here onwards for entire array []
        {
          id: 1,
          title: "My First Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },

and replace that with an empty array

  const [posts, setPosts] = useState([])

so we are left with this

  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const history = useHistory();

add the ;
and now this is really all we need to get the json server up and running.  v06.04.34

so now we go to package.json file in file tree

src
.gitignore
package-lock.json
package.json
README.md

now we need to add Axios as a new dependency

go to Chrome
npmjs.com/package/axios
in VSCode, open terminal window 	CONTROL `
type npm i for install axios and -S 
-S is a habit but no longer neededfa

$ npm i axios -S				v06.05.44
Enter

can now see Axios in package.json file as listed dependency
"axios": "^0.21.1",4

close terminal window
open src folder in file tree
add new folder inside src folder
new folder name is		api
new file created 		posts.js

add this code inside blank posts.js file

import axios from 'axios';

now we set the base url 
so we set 
export default axios.create({})
then on seperate line we define the base url property
and we set this to our http local host post 3500	'http://localhost:3500'
port 3500 is where we launch our json server on



export default axios.create()
export default axios.create({})
export default axios.create({

})

export default axios.create({
    baseURL: ''
})

export default axios.create({
    baseURL: 'http://localhost:3500'
});


save
now this is all we need in this file
now axios will continue to use this base url
if you are doing this to take this project live, 
then you would need to change this base url to whatever you
have as a base url for your host

open terminal window  CONTROL `
1st) inside this 1st terminal window we need to launch json server
-p means port
-w means watch

$ npx json-server -p 3500 -w data/db.json			v.06.07.30
Enter
By pressing Enter, this should launch our json server instance

2nd) lets launch react app in another terminal window

To open 2nd terminal window, click + sign 
and now you can see terminal window tree on right 
where we have two bash terminal windows running
In this 2nd terminal window, we launch our react app

$ npm start	

now notice that once we get this started, we should not see any posts
b/c we changed the state. (ie removed hardcoded posts from App.js file).
but then the react will show any changes we make as we add axios into 
our Application.

Chrome browser shows rendered app
Now our application is loaded with 'No posts to display.' and
this is what we expected since we cleared out the static state.
Now resize window so we can see VSCode on left 1/2 of screen and 
rendered app on Chrome on right 1/2 of screen.
Thus we can work on VSCode on left and view app on right.
Close terminal windows but note that they continue to run.
We can open the terminal windows at any time.
Open file tree CONTROL B

Go to App.js file
Hide file tree

now we need to import our API
import api from './api/posts';
so now we have imported the API and we can use it inside the Application

App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';			<<<<<<<<<<<<<<<<<<<<<<<NEW  v06.09.19

so now we have imported the API and can use it within the Application

now within App.js underneath the useHistory line (line 20)
  const history = useHistory(); line
press return and start another useEffect
this useEffect is where we will fetch our data

we only want this fetch to happen at load time 
so the depedency should be an empty array 		[]
now inside this useEffect we need to define our fetch function		const fetchPosts
this should be an async function					async () => {}

now inside the async function we have a try catch finally block		try {} catch ()
inside the catch we catch any possible error 				catch (err)
// continue explanation below

  useEffect()								v06.09.50
  useEffect(() => {})
  
  useEffect(() => {

  }, [])

  useEffect(() => {
    const fetchPosts = 
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {}
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
      } catch ()
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
      } catch (err)
    }
  }, [])

// continue explanation
we need to define how to use axios
so we define a response 					const response = 
we set the response equal to await api.		
remeber api. is the axios instance we are importing		api.

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.
      } catch (err)
    }
  }, [])

and now we use get						api.get
this is where axios becomes very easy to understand b/c
we actually use the verbage the words that we could in a CRUD operation
for api usage so such as http uses get post put delete patch and a few others
but we are going to only use the basic CRUD operations
so get is our read operation in CRUD
so now we just need to say what endpoint we want with that base url
this application only has 1 endpoint which is /posts		api.get('/posts');
(--> ie get the Posts)
so now we need to define this
and note that this (ie axios) replaces fetch
and so what is so nice about axios instead of fetch are (1) (2) 
(1) axios automatically creates the json so we dont need the 
2nd step to define data and then set it equal to response.json
(2) axios will automatically catch the errors when the errors are not
in the 200 range of http responses					v06.11.50
so before where we would have said 
      if (!response.ok)
if the response.ok was false
we dont have to do this b/c axios will 
automatically catch anything outside of the 200 range
so what we can do is
set our state with setPosts()					setPosts()
(--> ie setting Posts state)

b/c if we get to this point then *** automatically an error has not occurred *** 
and thus we know its already in the 200 range
we put our data into the (response.data)			setPosts(resposne.data)

note that some you see might say
if we have a resposne
and if we the data
  if (response && response.data)
and you can do this to be extra careful
we dont do that here b/c we know we have a response in the 200 range
and if we have a 200 range response then we know that our json server
is absolutely going to send data back
Also, if you are working with someone who is working the backend, then
you might know already know that you will be getting a response
in that 200 range
But if not, then this is how you could check for this to make sure you
have a response.

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get
      } catch (err)
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
      } catch (err)
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts()					<<<<<<<<<<<<setPosts()
      } catch (err)
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)				<<<<<<<<<<<<setPosts(response.data)
      } catch (err)			<<<<<<<<<<<<<<<<<<<<<see below
    }
  }, [])


v06.13.23

Need to capture backend API reponses
sometimes they will be 200 responses, non-200 (404) responses, or no response at all

now axios catches those errors
// Not in the 200 response range
this is copied pasted directly from axios documentation
axios will log all these errror categories (and more): data, status, headers

      } catch (err) {
        // Not in the 200 response range
          console.log();
          console.log();
          console.log();

      } catch (err) {
        // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);

so if your backend was sending a message,
        console.log(err.response.data);

then you would receive the message like this
        console.log(err.response.data.message);

it will just depend on what the backend is delivering
when its not in the 200 range, so you must know (be aware) of
what you are dealing with (ie aware of the api that you are working with)
to actually know what property to pull out of that data

you can also do this for the status and the headers

but axios will also catch other possible errors so we need to add code for this
this means we have an error and its response property
        if (err.response) {}

ie errors in:
- 200 range vs					// no error 
- some other # range vs 			// yes errors but Not in the 200 response range
- undefined					// yes error but its an undefined error

      } catch (err) {
        if (err.response) {
          // Not in the 200 response range
          // add code here			console.log(err.response.data);
          // add code here			console.log(err.response.status);
          // add code here			console.log(err.response.headers);
        } else {
          // Undefined error
          // add code here 			console.log(``);		// template literal
          // add code here 			console.log(`Error:`);
          // add code here 			console.log(`Error: ${}`);
          // add code here 			console.log(`Error: ${err.message}`);
        }


  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)
      } catch (err) {
        if 
          // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);
      } else {
          console.log(`Error: ${err.message}`)		// template literal		v06.15.00
      }
    }
  }, [])


so if we get to this
we know we did not get any response at all from the backend API

         console.log(`Error: ${err.message}`)		// template literal		v06.15.00

this is directly from the axios documentation
and so axios handles those errors very well
and we can pull out extra data if we need to		v06.15.33

now our function for fetchPosts is now defined
but we still need to call fetchPosts() inside useEffect <<<<<<<<<<<<<<<<<<<<<<<<HERE

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)
      } catch (err) {
        if 
          // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);
      } else {
          console.log(`Error: ${err.message}`)		// template literal		v06.15.00
      }
    }

    fetchPosts(); 			<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<HERE
  }, [])


save
now we can see our posts in the rendered Chrome app v06.15.46 --> 06.15.48
our development server loaded the page as soon as we saved our changes

Now we can make a New Post on the Post page in our application

So now the next thing we need to adjust in our application is the handleSubmit function
v06.16.23
this is the C in CRUD		Create a new post

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody }; <<<<New Post created here so add line
    // add C code here
    const allPosts = [...posts, newPost];
    setPosts(allPosts);
    setPostTitle('');
    setPostBody('');
    history.push('/');
  }

add try{}
delete ending curly brace
Now for all lines after this (const allPosts, setPosts(allPosts), setPostTitle, setPostBody, history,push)
all these lines should be inside the try block 
b/c they are for New Post creation
Add } curly brace at end of this try segment 
b/c we dont want to make any of those lines
happen if our try {} block fails

    // add C code here
    try {}

    try {
      const allPosts = [...posts, newPost];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    }

Now catch the error				    catch (err) {

    try {
      const allPosts = [...posts, newPost];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {


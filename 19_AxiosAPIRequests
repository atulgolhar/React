we have App.js
Need to 
create data folder 			data
create new file db.json			db.json

inside db.json
we can add and modify data from within the App component
right now we have a static state for posts 
these are objects inside an array
(ie post data is hard coded inside App.js 
so any changes to posts then reload App will result in 
default hardcoded posts remaining inside App).
Need to make post state dynamic (thus eliminate hardcoding).
We cut hardcoded posts from App.js and paste into db.json file
and need to add quotes some elements.

so here we have an object		{
we have given it the name "posts"	"posts":
key-value so the value for this property is the array		[
notice that each of the json objects are within quotes ""
vs no quotes in the hard coded json data in the App component
therefore you need to ensure that you are formatting like this in db.json v06.04.09
now save b/c we have the db.json file inside the data folder

{
    "posts": [
      {
        "id": 1,							added "" to key
        "title": "My First Post"					added "" to key



OLD 
App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home';
import NewPost from './NewPost';
import PostPage from './PostPage';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';

function App() {
  const [posts, setPosts] = useState([
        {
          id: 1,
          title: "My First Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },
        {
          id: 2,
          title: "My 2nd Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },
        {
          id: 3,
          title: "My 3rd Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },
        {
          id: 4,
          title: "My 4th Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        }
      ])

  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const history = useHistory();

hardcoded posts code here

function App() {
    const [posts, setPosts] = useState([
        {
          id: 1,							missing "" for key
          title: "My First Post"					missing "" for key
          datetime: "July 01, 2023 11:17:36 AM"				missing "" for key
          body: "Lorem ipsum dolor sit amet consectuor elit."		missing "" for key
        },


db.json properly formated posts here
{
    "posts": [
      {
        "id": 1,							added "" to key
        "title": "My First Post"					added "" to key
        "datetime": "July 01, 2023 11:17:36 AM"				added "" to key
        "body": "Lorem ipsum dolor sit amet consectuor elit."		added "" to key
      },

v06.04.18
now we go back to the App.js file
function App() {
  const [posts, setPosts] = useState([
				     ^ from here onwards for entire array []
        {
          id: 1,
          title: "My First Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },

and replace that with an empty array

  const [posts, setPosts] = useState([])

so we are left with this

  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const history = useHistory();

add the ;
and now this is really all we need to get the json server up and running.  v06.04.34

so now we go to package.json file in file tree

src
.gitignore
package-lock.json
package.json
README.md

now we need to add Axios as a new dependency

go to Chrome
npmjs.com/package/axios
in VSCode, open terminal window 	CONTROL `
type npm i for install axios and -S 
-S is a habit but no longer neededfa

$ npm i axios -S				v06.05.44
Enter

can now see Axios in package.json file as listed dependency
"axios": "^0.21.1",4

close terminal window
open src folder in file tree
add new folder inside src folder
new folder name is		api
new file created 		posts.js

add this code inside blank posts.js file

import axios from 'axios';

now we set the base url 
so we set 
export default axios.create({})
then on seperate line we define the base url property
and we set this to our http local host post 3500	'http://localhost:3500'
port 3500 is where we launch our json server on



export default axios.create()
export default axios.create({})
export default axios.create({

})

export default axios.create({
    baseURL: ''
})

export default axios.create({
    baseURL: 'http://localhost:3500'
});


save
now this is all we need in this file
now axios will continue to use this base url
if you are doing this to take this project live, 
then you would need to change this base url to whatever you
have as a base url for your host

open terminal window  CONTROL `
1st) inside this 1st terminal window we need to launch json server
-p means port
-w means watch

$ npx json-server -p 3500 -w data/db.json			v.06.07.30
Enter
By pressing Enter, this should launch our json server instance

2nd) lets launch react app in another terminal window

To open 2nd terminal window, click + sign 
and now you can see terminal window tree on right 
where we have two bash terminal windows running
In this 2nd terminal window, we launch our react app

$ npm start	

now notice that once we get this started, we should not see any posts
b/c we changed the state. (ie removed hardcoded posts from App.js file).
but then the react will show any changes we make as we add axios into 
our Application.

Chrome browser shows rendered app
Now our application is loaded with 'No posts to display.' and
this is what we expected since we cleared out the static state.
Now resize window so we can see VSCode on left 1/2 of screen and 
rendered app on Chrome on right 1/2 of screen.
Thus we can work on VSCode on left and view app on right.
Close terminal windows but note that they continue to run.
We can open the terminal windows at any time.
Open file tree CONTROL B

Go to App.js file
Hide file tree

now we need to import our API
import api from './api/posts';
so now we have imported the API and we can use it inside the Application

App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';			<<<<<<<<<<<<<<<<<<<<<<<NEW  v06.09.19

so now we have imported the API and can use it within the Application
now within App.js underneath the useHistory line (line 20)
  const history = useHistory(); line
press return and start another useEffect
this useEffect is where we will fetch our data

we only want this fetch to happen at load time 
so the depedency should be an empty array 		[]
now inside this useEffect we need to define our fetch function		const fetchPosts
this should be an async function					async () => {}

now inside the async function we have a try catch finally block		try {} catch ()
inside the catch we catch any possible error 				catch (err)
// continue explanation below

  useEffect()								v06.09.50
  useEffect(() => {})
  
  useEffect(() => {

  }, [])

  useEffect(() => {
    const fetchPosts = 
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {}
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
      } catch ()
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
      } catch (err)
    }
  }, [])

// continue explanation
we need to define how to use axios
so we define a response 					const response = 
we set the response equal to await api.		
remeber api. is the axios instance we are importing		api.

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.
      } catch (err)
    }
  }, [])

and now we use get						api.get
this is where axios becomes very easy to understand b/c
we actually use the verbage the words that we could in a CRUD operation
for api usage so such as http uses get post put delete patch and a few others
but we are going to only use the basic CRUD operations
so get is our read operation in CRUD
so now we just need to say what endpoint we want with that base url
this application only has 1 endpoint which is /posts		api.get('/posts');
(--> ie get the Posts)
so now we need to define this
and note that this (ie axios) replaces fetch
and so what is so nice about axios instead of fetch are (1) (2) 
(1) axios automatically creates the json so we dont need the 
2nd step to define data and then set it equal to response.json
(2) axios will automatically catch the errors when the errors are not
in the 200 range of http responses					v06.11.50
so before where we would have said 
      if (!response.ok)
if the response.ok was false
we dont have to do this b/c axios will 
automatically catch anything outside of the 200 range
so what we can do is
set our state with setPosts()					setPosts()
(--> ie setting Posts state)

b/c if we get to this point then *** automatically an error has not occurred *** 
and thus we know its already in the 200 range
we put our data into the (response.data)			setPosts(resposne.data)

note that some you see might say
if we have a resposne
and if we the data
  if (response && response.data)
and you can do this to be extra careful
we dont do that here b/c we know we have a response in the 200 range
and if we have a 200 range response then we know that our json server
is absolutely going to send data back
Also, if you are working with someone who is working the backend, then
you might know already know that you will be getting a response
in that 200 range
But if not, then this is how you could check for this to make sure you
have a response.

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get
      } catch (err)
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
      } catch (err)
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts()					<<<<<<<<<<<<setPosts()
      } catch (err)
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)				<<<<<<<<<<<<setPosts(response.data)
      } catch (err)			<<<<<<<<<<<<<<<<<<<<<see below
    }
  }, [])


v06.13.23

Need to capture backend API reponses
sometimes they will be 200 responses, non-200 (404) responses, or no response at all

now axios catches those errors
// Not in the 200 response range
this is copied pasted directly from axios documentation
axios will log all these errror categories (and more): data, status, headers

      } catch (err) {
        // Not in the 200 response range
          console.log();
          console.log();
          console.log();

      } catch (err) {
        // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);

so if your backend was sending a message,
        console.log(err.response.data);

then you would receive the message like this
        console.log(err.response.data.message);

it will just depend on what the backend is delivering
when its not in the 200 range, so you must know (be aware) of
what you are dealing with (ie aware of the api that you are working with)
to actually know what property to pull out of that data

you can also do this for the status and the headers

but axios will also catch other possible errors so we need to add code for this
this means we have an error and its response property
        if (err.response) {}

ie errors in:
- 200 range vs					// no error 
- some other # range vs 			// yes errors but Not in the 200 response range
- undefined					// yes error but its an undefined error

      } catch (err) {
        if (err.response) {
          // Not in the 200 response range
          // add code here			console.log(err.response.data);
          // add code here			console.log(err.response.status);
          // add code here			console.log(err.response.headers);
        } else {
          // Undefined error
          // add code here 			console.log(``);		// template literal
          // add code here 			console.log(`Error:`);
          // add code here 			console.log(`Error: ${}`);
          // add code here 			console.log(`Error: ${err.message}`);
        }


  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)
      } catch (err) {
        if 
          // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);
      } else {
          console.log(`Error: ${err.message}`)		// template literal		v06.15.00
      }
    }
  }, [])


so if we get to this
we know we did not get any response at all from the backend API

         console.log(`Error: ${err.message}`)		// template literal		v06.15.00

this is directly from the axios documentation
and so axios handles those errors very well
and we can pull out extra data if we need to		v06.15.33

now our function for fetchPosts is now defined
but we still need to call fetchPosts() inside useEffect <<<<<<<<<<<<<<<<<<<<<<<<HERE

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)
      } catch (err) {
        if 
          // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);
      } else {
          console.log(`Error: ${err.message}`)		// template literal		v06.15.00
      }
    }

    fetchPosts(); 			<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<HERE
  }, [])


save
now we can see our posts in the rendered Chrome app v06.15.46 --> 06.15.48
our development server loaded the page as soon as we saved our changes

Now we can make a New Post on the Post page in our application

So now the next thing we need to adjust in our application is the handleSubmit function
v06.16.23
this is the C in CRUD		Create a new post

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody }; <<<<New Post created here so add line
    // add C code here
    const allPosts = [...posts, newPost];
    setPosts(allPosts);
    setPostTitle('');
    setPostBody('');
    history.push('/');
  }

add try{}
delete ending curly brace
Now for all lines after this (const allPosts, setPosts(allPosts), setPostTitle, setPostBody, history,push)
all these lines should be inside the try block 
b/c they are for New Post creation
Add } curly brace at end of this try segment 
b/c we dont want to make any of those lines
happen if our try {} block fails

    // add C code here
    try {}

    try {
      const allPosts = [...posts, newPost];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    }

Now catch the error					catch (err) {
add console.log with template literal			console.log(`Error: ${err.message}`)
so this way, at least we know that we are grabbing the message and logging it
ie we are acknowledging that we might get an error in this development application

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody }; <<<<New Post created here so add line
    // add C code here
    const allPosts = [...posts, newPost];		<<<<MOVE FROM HERE
    setPosts(allPosts);					<<<<MOVE FROM HERE
    setPostTitle('');					<<<<MOVE FROM HERE
    setPostBody('');					<<<<MOVE FROM HERE
    history.push('/');					<<<<MOVE FROM HERE
    try {
      const allPosts = [...posts, newPost];		<<TO HERE
      setPosts(allPosts);				<<TO HERE
      setPostTitle('');					<<TO HERE
      setPostBody('');					<<TO HERE
      history.push('/');				<<TO HERE
    } catch (err) {					<<<<<<<<<<<<<<<<<<<catch err
        console.log(`Error: ${err.message}`);		<<<<<<<<<<<<<<<<<<<err.message
    }
  }


so far we have
but remember this was focused on a newPost
so we address this now. So far we have

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody }; <<<<New Post created here so add line
    try {
      const response 					<<<<<<<<<HERE
      const allPosts = [...posts, newPost];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

Now in the try block, we need to define a response
so const response is equal to await api.
but now we are posting a new blog post so its 	api.post
Before we used api.get			const response = api.get('/posts');
Now we use api.post			const response = api.post
We use api.post b/c we are posting a new blog post
Then we need to define the endpoint 	  	('/posts'
then we pass in the new post			         , newPost);

      const response
      const response = await
      const response = await api.
      const response = await api.post()
      const response = await api.post('/posts')
      const response = await api.post('/posts', newPost);

so now we have

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody }; <<<<New Post created here so add line
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, newPost];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

Now after we added the await api.post code
we need to see where we are
we need to now alter allPosts b/c we just added a new post but didnt yet change allPosts
we need to change newPost to response.data
      const response = await api.post('/posts', newPost);

note that response.data should be the same as the newPost

      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, newPost];
				  ^^^^^^^
why? b/c it should be just the api sending us the data back into response from line above it

      const allPosts = [...posts, newPost];			// OLD
      const allPosts = [...posts, response.data];		// NEW
				  ^^^^^^^^^^^^^

so what happens is we try to define response as response ingests the api newPost response
then that newPost is the same as response.data
so we just use response.data  

    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, newPost];


      const allPosts = [...posts, newPost];
				  ^^^^^^^
      const allPosts = [...posts, response.data];
				  ^^^^^^^^^^^^^

so we now have
response.data instead of newPost
then we setPosts to allPosts
we still empty out our controlled form that has the Title and the Body
and then we use history.push to go back to the actual blog to 
see the full list in the blog feed thus we now now have an updated history
and nothing else changes
so we just use axios to
(1) send the new data 
      const response = await api.post('/posts', newPost);
(2) then we update the state with the actual response we get from the api
    thus we extract the .data out of the response

thus updated code is

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];		// response.data is the newPost data
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

now save
notice that we have an error
b/c we added await but not add async to this as can can not await without async

  const handleSubmit = (e) => {
  const handleSubmit = async (e) => {

now save again
App renders ok

Lets make a New Post with the title: Test Post for Tutorial
add Body text to the New Post
Enter
Rendered app now shows that Test Post in the Blog. It works.		v06.19.40

start with this

  const handleDelete = (id) => {
    const postsList = posts.filter(post => post.id !== id);
    setPosts(postsList);
    history.push('/');
  }


add async
Add try block
Everything that was there before will now be inside of try block
Then after try block we add the same catch block as used in handleSubmit
v06.20.17


  const handleDelete = async (id) => {					<<<<<<<add async
    try {								<<<<<<<add try block
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {							<<<<<<<add catch block
        console.log(`Error: ${err.message}`);
    }
  }


v06.20.17

now inside to try, we may not get a response right away sp 
we need to await a response				await 
api.delete call delete					api.delete()
use a template literal ``				(``)
we pass in the endpoint /posts				(`/posts/`)
we also need the specific post id 			${id}

  const handleDelete = async (id) => {
    try {
      await api.delete
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

      await api.delete
      await api.delete()
      await api.delete(``)
      await api.delete(`/posts/`)
      await api.delete(`/posts/${}`)
      await api.delete(`/posts/${id}`)

so we now have 

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }


save
Now in Chrome App, go to the Test Post page and try to delete the Post
now everything seems to be working as it should for the delete operation
So far we have Create, Read and Delete completed
and now for the more complex of the 4 operations is Update

App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');		<<<<<DULPLICATE THIS FOR editTitle, editBody
  const [postBody, setPostBody] = useState('');
  const history = useHistory();

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)
      } catch (err) {
        if 
          // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);
      } else {
          console.log(`Error: ${err.message}`)
      }
    }

    fetchPosts();
  }, [])


  useEffect(() => {
    const filteredResults = posts.filter(post => 
      ((post.body).toLowerCase()).includes(search.toLowerCase())
      || ((post.title).toLowerCase()).includes(search.toLowerCase()));

    setSearchResults(filterResults.reverse());
  }, [posts, search])							


  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  return (
     <div className="App">
       <Header title="React JS Blog"/>
       <Nav search={search} setSearch={setsearch} />
       <Switch>		
         <Route exact path="/"
           <Home posts={posts}/>
         </Route>
         <Route exact path="/post"
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
     </div>
  )
}


v06.21.08

lets create the function
call it handleEdit b/c we are going to edit the post
add it just above handleDelete
its an anonymous function, need the id of the post
this will be async
now inside the handleEdit, we will need some new state	v06.21.30
take postTitle and postBody lines, copy and paste then change
to editTitle and editBody
thus postTitle setPostTitle becomes editTitle setEditTitle
thus postBody setPostBody becomes editBody setEditBody

  const handleEdit
  const handleEdit = async						v06.21.13
  const handleEdit = () => {}
  const handleEdit = (id) => {}
  const handleEdit = async (id) => {}

  const handleEdit = async (id) => {

  }


function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');		<<<<<DULPLICATE THIS FOR editTitle, editBody
  const [postBody, setPostBody] = useState('');
  const history = useHistory();

  const [postTitle, setPostTitle] = useState('');		<<<<<DULPLICATE THIS FOR editTitle, editBody
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');		<<<<<DULPLICATE THIS FOR editTitle, editBody
  const [editBody, setEditBody] = useState('');

so we have 

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');		<<<<<
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');		<<<<<
  const [editBody, setEditBody] = useState('');
  const history = useHistory();

so now we have editTitle editBody setEditTitle setEditBody
and we use those in our function for handleEdit
we start with needing the datetime and newPost lines from handleSubmit
so first lets copy those 
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
then paste into handleEdit
datetime will not change
newPost will change to updatedPost
and instead of postTitle, we have editTitle
and instead of postBody, we have editBody
why change these? b/c these will be controlled form where we make those edits
so we need to pieces of controlled state as well to make those edits

  const handleEdit = async (id) => {

  }

  const handleEdit = async (id) => {
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
  }


    const newPost = { id, title: postTitle, datetime, body: postBody };		<<<<postTile, postBody  OLD
    const updatedPost = { id, title: editTitle, datetime, body: editBody };	<<<<editTitle, editBody NEW


so now we have

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
  }

now we can start the try {} block  				v06.22.47
copy catch block from above
inside the try block
start with a const response				const response
set that equal to await					= await 
call our api and now we call .put()				api.put()
instead of put, 
we could use patch if we were updating specific fields
but here we are replacing the entire post
inside the put, we put in the endpoint (`/posts/`)			(`/posts/`)
now we need to be specific to the id of the post using ${id}		(`/posts/${id}`)
after this we pass in our new data which is the updatedPost		(`/posts/${id}`, updatedPost);

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
    try{
      const response		<<<<<<<<<<<<<<<<<<ADD HERE
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

      const response = await 
      const response = await api.put()
      const response = await api.put(`/posts/`)
      const response = await api.put(`/posts/${id}`)
      const response = await api.put(`/posts/${id}`, updatePost);

so now we have

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
    try{
      const response = await api.put(`/posts/${id}`, updatePost);
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

so now we have a response back from axios and the backend API
we use setPosts() here 
but this is a little more complex than we did earlier when 
we just send in all the posts 
      const allPosts = [...posts, response.data];
      setPosts(allPosts);		<<<<<<<<<<<<<<<< simple version
its more complex then the handleSubmit version b/c we need to use map
      setPosts(posts.map)
why?
before all we did was send in the posts 
now we need to use map
b/c if we dont then we are creating an array of old and 
then sending in the new posts as well
key is to eliminate the old posts and just add the new info

so with map
we have each post iterated thru		      		(post => )
map will create a new array by checking 
the post.id strictly equals the new id we passed in	=> post.id === id ))
then ternary statement					? )) 
if true then within this expression {}			{}
lets use the ...response.data				{ ...response.data}
note that the response.data is the new post information
and so if the id is equal to the post id passed in
and if not :						:
then just pass in the post as it is			post

so all this means that only where the post ids match 	post.id === id
is when we pass in the new data				? { ...response.data }
so note that the updatedPost is the same as the destructured { ...response.data }
so this will update our post state 			;

      setPosts(posts.map)
      setPosts(posts.map(post => post.id === id ))
      setPosts(posts.map(post => post.id === id ? ))
      setPosts(posts.map(post => post.id === id ? {} ))
      setPosts(posts.map(post => post.id === id ? { ...response.data } ))
      setPosts(posts.map(post => post.id === id ? { ...response.data } : ))
      setPosts(posts.map(post => post.id === id ? { ...response.data } : post))
      setPosts(posts.map(post => post.id === id ? { ...response.data } : post));

so now we have  		v06.25.02

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
    try{
      const response = await api.put(`/posts/${id}`, updatePost);
      setPosts(posts.map(post => post.id === id ? { ...response.data } : post));  <<<<<<<<<<<<<<<NEW
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

now we still need to setEditTitle('') back to a blank title
we also need to setEditBody('') back to a blank b/c
we dont want to hold that over for the controlled form in any way
then after that we use history.push to go back to the main feed
so we can see our editted post amongst all the other posts
and save
this should complete the handle edit function

      setPosts(posts.map(post => post.id === id ? { ...response.data } : post));  <<<<<<<<<<<<<<<NEW
      setEditTitle('');
      setEditBody('');
      history.push('/');

so now we have  		v06.25.35

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
    try{
      const response = await api.put(`/posts/${id}`, updatePost);
      setPosts(posts.map(post => post.id === id ? { ...response.data } : post));  <<<<<<<<<<<<<<<NEW
      setEditTitle('');								<<<<<<<<<<<<<<<NEW
      setEditBody('');								<<<<<<<<<<<<<<<NEW
      history.push('/');							<<<<<<<<<<<<<<<NEW
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

save
resize VSCode in order to see the Chrome rendered app
right now we have no way to get to a new component and 
we dont have the edit component yet
so lets create the edit component and the pathway to get to it

so file tree again in VSCode
highlight the src folder
create new file EditPost.js
CONTROL ALT R to use ES React 7 snippets
_rafce

this produces

const EditPost = () => {
    return (
        <div>

        </div>
    )
}

export default EditPost


we need to make some imports at the top of this component
the first import will be useEffect from react
next import useParams and Link from react router DOM

import { useEffect } from "react";
import ( useParams, Link } from "react-router-dom";

so we have

import { useEffect } from "react";
import ( useParams, Link } from "react-router-dom";

const EditPost = () => {
    return (
        <div>

        </div>
    )
}

export default EditPost

next inside EditPost
we bring in somem props	{}
we will need all the posts
we will need our handleEdit function
we will need the editBody function
we will need the setEditBody
we will need the editTitle and setEditTitle

const EditPost = ({}) => {
const EditPost = ({
    posts, handleEdit, editBody, setEditBody, editTitle, setEditTitle
}) => {


so we have

import { useEffect } from "react";
import ( useParams, Link } from "react-router-dom";

const EditPost = ({
    posts, handleEdit, editBody, setEditBody, editTitle, setEditTitle
}) => {
    return (
        <div>

        </div>
    )
}

export default EditPost


next we build the function

import { useEffect } from "react";
import ( useParams, Link } from "react-router-dom";

const EditPost = ({
    posts, handleEdit, editBody, setEditBody, editTitle, setEditTitle
}) => {
    // build out function here	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<HERE
    return (
        <div>

        </div>
    )
}

export default EditPost


this is really a combination of our new post page 
(where we created a newPost with a controlled form)
but also our post detail page where we pulled in
the post details from the parameters which is why we are using useParams
create the id just like we did in the post page to get the post detail
we use useParams right away to the id attribute that we need to set in the route

    // build out function here
    const {}
    const { id }
    const { id } = useParams
    const { id } = useParams();

then we need to get the specific posts
so start with const post equal to
posts.find just like we did on the post detail page
using an arrow function
we use (post.id).toString b/c when it comes out of the params in the url
it is a string and that is what we are matching
and we must set the post.id to toString to actually use strict equals.
Note you could just use the double equals == and not do the toString() part
but this is your preference

    const post = 
    const post = posts.find()
    const post = posts.find(post => )
    const post = posts.find(post => ())
    const post = posts.find(post => (post.id).toString)
    const post = posts.find(post => (post.id).toString())
    const post = posts.find(post => (post.id).toString() === id);


so now we have EditPost.js

import { useEffect } from "react";
import ( useParams, Link } from "react-router-dom";

const EditPost = ({
    posts, handleEdit, editBody, setEditBody, editTitle, setEditTitle
}) => {
    const { id } = useParams();
    const post = posts.find(post => (post.id).toString() === id);

    // add useEffect() here

    return (
        <div>

        </div>
    )
}

export default EditPost


so now we have the post and id
we can use useEffect()
with an anonymous function

so when this loads, we need to pull in this data		v06.28.52
and set the state for that 
so for the dependencies 
inside the array we need post, setEditTitle, setEditBody

post, setEditTitle, setEditBody are the dependencies 

    useEffect()

    useEffect(() => {})

    useEffect(() => {
    })

    useEffect(() => {
    }, [])

    useEffect(() => {
    }, [post, setEditTitle, setEditBody])

and now inside useEffect, we need to 				v06.29.08
set the state for both of these setEditTitle and setEditBody

so if we have a post		        			if (post)
why if?
there is a chance the page is requested but
the post does not exist

so if we have a post
then we setEditTitle				setEditTitle(post.title);
and we setEditBody				setEditBody(post.body);

    useEffect(() => {
        if (post) {

        }
    }, [post, setEditTitle, setEditBody])

    useEffect(() => {
        if (post) {
            setEditTitle(post.title);
            setEditBody(post.body);
        }
    }, [post, setEditTitle, setEditBody])


so now we have EditPost.js

import { useEffect } from "react";
import ( useParams, Link } from "react-router-dom";

const EditPost = ({
    posts, handleEdit, editBody, setEditBody, editTitle, setEditTitle
}) => {
    const { id } = useParams();
    const post = posts.find(post => (post.id).toString() === id);

    useEffect(() => {
        if (post) {
            setEditTitle(post.title);
            setEditBody(post.body);
        }
    }, [post, setEditTitle, setEditBody])

    return (
        <div>

        </div>
    )
}

export default EditPost



so now that we have these two, 
		two means setEditTitle and setEditBody
we have set the state
and so the form will already be filled out
(ie by setting the state, the form will therefore be filled out)

and now our controlled form will be ready to edit the existing post

Now the body of the post page will be much like the new post page
so lets go to the new post page
so we can select from the beginning of the main element to 
the closing main element tag of NewPost.js

and we take that NewPost.js code block (of <main> tag to closing </main> tag)


for summary sake, the NewPost.js component code is

const NewPost = ({
    handleSubmit, postTitle, setPostTitle, postBody, setPostBody
}) => {
    return (
        <main className="NewPost">				<<<<<<<<FROM HERE TO
            <h2>New Post</h2>
            <form className="newPostForm" onSubmit=>{handleSubmit}>
	        <label htmlFor="postTitle">Title:</label>
	        <input
	            id="postTitle"
	            type="text"
	            required
	            value={}
	            onChange={(e) => setPostTitle(e.target.value)}
	        />
	        <label htmlFor="postBody">Post:</label>
	        <textarea
	          id="postBody'
	          required
	          value={postBody}
	          onChange={(e) => setPostBody(e.target.value)}
	        />
                <button type="submit" \>Submit</button>
            </form>
        </main>							<<<<<<<<TO HERE
    )
}

export default NewPost





so now we have EditPost.js
and copy in the <main> tag block over the <div> tags
so we replace the <div> tags with the <main> tag block
resulting in this code for EditPost.js component		v06.30.06
Now there will be some slight changes to the code, we tackle
that below this code block.

import { useEffect } from "react";
import ( useParams, Link } from "react-router-dom";

const EditPost = ({
    posts, handleEdit, editBody, setEditBody, editTitle, setEditTitle
}) => {
    const { id } = useParams();
    const post = posts.find(post => (post.id).toString() === id);

    useEffect(() => {
        if (post) {
            setEditTitle(post.title);
            setEditBody(post.body);
        }
    }, [post, setEditTitle, setEditBody])

    return (
        <main className="NewPost">				<<<<<<<<FROM HERE TO
            <h2>New Post</h2>
            <form className="newPostForm" onSubmit=>{handleSubmit}>
	        <label htmlFor="postTitle">Title:</label>
	        <input
	            id="postTitle"
	            type="text"
	            required
	            value={}
	            onChange={(e) => setPostTitle(e.target.value)}
	        />
	        <label htmlFor="postBody">Post:</label>
	        <textarea
	          id="postBody'
	          required
	          value={postBody}
	          onChange={(e) => setPostBody(e.target.value)}
	        />
                <button type="submit" \>Submit</button>
            </form>
        </main>							<<<<<<<<TO HERE
    )
}

export default EditPost


slight changes are needed here
className remains the same
format is the same
but need to add new lines after main element		{}
{if we have an editTitle && }
(ie so post needs to exist for it to have an editTitle)   		v06.30.29

VSCode does not like this edit b/c in JSX you must have a parent element
and right now no parent element exists

        <main className="NewPost">
            <h2>New Post</h2>
            <form className="newPostForm" onSubmit=>{handleSubmit}>

        <main className="NewPost">
            {editTitle}
            <h2>New Post</h2>
            <form className="newPostForm" onSubmit=>{handleSubmit}>

add ending curly brace after closing </form> tag
and tab over the text

            </form>
        </main>

                </form>
            }
        </main>

now back to beginning of the <main> tag
that JSX error is looking for a parent element
so we can add a fragment tags here			<> </>


        <main className="NewPost">
            {editTitle}
            <>
                <h2>New Post</h2>
                <form className="newPostForm" onSubmit=>{handleSubmit}>
            </>

so notice, by adding the fragment tag <> then VSCode accepts the change and
thus the self generated VSCode errors are now gone

more detail on VCode errors and parent element requirement - note that 
<h2> and <form> tags are both sibling elements so this is why JSX and VSCode 
would not accept it

so now we have this with new tabs

    return (
        <main className="NewPost">
            {editTitle}
            <>
                <h2>New Post</h2>
                <form className="newPostForm" onSubmit=>{handleSubmit}>
	            <label htmlFor="postTitle">Title:</label>
	            <input
	                id="postTitle"
       	                type="text"
	                required
	                value={postTitle}
	                onChange={(e) => setPostTitle(e.target.value)}
     	            />
	            <label htmlFor="postBody">Post:</label>
	            <textarea
	                id="postBody'
	                required
	                value={postBody}
	                onChange={(e) => setPostBody(e.target.value)}
	            />
                    <button type="submit" \>Submit</button>
                </form>
            </>
        </main>
    )


change New Post title to Edit Post
                <h2>New Post</h2>
                <h2>Edit Post</h2>
lets step thru each line of code and verify if keep or make changes
                <form className="newPostForm" onSubmit=>{handleSubmit}>
keep the className the same as want the same formatting from CSS
but onSubmit should not be calling handleSubmit

instead of this
		onSubmit=>{handleSubmit}

instead onSubmit will call a prevent default (as we often do with a form)

we want the event e to prevent default as 
we have done in the past here with a form
		onSubmit=>{(e) => e.preventDefault()}
and so when this happens then 
that means inside the button 
we need to have an onClick and 
set this equal to anonymous function

Inside this anonymous function we call the handleEdit
and need to pass in the post.id

This is why we dont do this in the onSubmit code but rather do
it in the onClick code

                    <button type="submit" \>Submit</button>
                    <button type="submit" onClick={} \>Submit</button>
                    <button type="submit" onClick={() => } \>Submit</button>
                    <button type="submit" onClick={() => handleEdit } \>Submit</button>
                    <button type="submit" onClick={() => handleEdit(post.id)} \>Submit</button>

Now for the controlled form to work
we need to update some of the names in the input tag
instead of postTitle its editTitle
instead of setPostTitle its setEditTitle		v 06.32.34

	            <input
	                id="postTitle"
       	                type="text"
	                required
	                value={postTitle}					<<<<<editTitle
	                onChange={(e) => setPostTitle(e.target.value)}		<<<<<setEditTitle
     	            />

	            <input
	                id="postTitle"
       	                type="text"
	                required
	                value={editTitle}					<<<<<
	                onChange={(e) => setEditTitle(e.target.value)}		<<<<<
     	            />

and the same logic applies here as well
change postBody to editBody
change setPostBody to setEditBody

we could also change the id here 	id="postBody' 	but we know that 
this component will not load at the same time as our new Post Form b/c 
there will be only 1 form showing per page at a time

	            <label htmlFor="postBody">Post:</label>
	            <textarea
	                id="postBody'
	                required
	                value={editBody} 					<<<<
	                onChange={(e) => setEditBody(e.target.value)}		<<<<
	            />

so now we have EditPost.js 

import { useEffect } from "react";
import ( useParams, Link } from "react-router-dom";

const EditPost = ({
    posts, handleEdit, editBody, setEditBody, editTitle, setEditTitle
}) => {
    const { id } = useParams();
    const post = posts.find(post => (post.id).toString() === id);

    useEffect(() => {
        if (post) {
            setEditTitle(post.title);
            setEditBody(post.body);
        }
    }, [post, setEditTitle, setEditBody])

    return (
        <main className="NewPost">			
            {editTitle &&				// cut } from here and paste below in this code block
                <>
                    <h2>Edit Post</h2>
                    <form className="newPostForm" onSubmit=>{(e) => e.preventDefault()}>
	                <label htmlFor="postTitle">Title:</label>
	                <input
	                    id="postTitle"
       	                    type="text"
	                    required
	                    value={editTitle}
	                    onChange={(e) => setEditTitle(e.target.value)}
     	                />
	                <label htmlFor="postBody">Post:</label>
	                <textarea
	                    id="postBody'
	                    required
	                    value={editBody} 
	                    onChange={(e) => setEditBody(e.target.value)}
	                />
                        <button type="submit" onClick={() => handleEdit(post.id)} \>Submit</button>
                    </form>
                </>
           }
           {!editTitle &&
                <>
                    <h2>Post Not Found</h2>
                    <p>Well, that's disappointing.</p>
                    <p>
                        <Link to='/'>Visit Our Homepage</Link>
                    </p>
                </>
     )
}

export default EditPost


now save these changes   v06.32.52
now we have created our new component

once we save these changes, we will have created our new component 
but (1) its still not being routed to in the App.js
    (2) we have no way of navigating there (ie thus we have no way of getting there)

so lets go to our App.js
scroll down to the routes
copy the <Route> block and paste it below

  return (
     <div className="App">
       <Header title="React JS Blog"/>
       <Nav search={search} setSearch={setsearch} />
       <Switch>		
         <Route exact path="/"
           <Home posts={posts}/>
         </Route>
         <Route exact path="/post"		<<<<<ROUTES HERE, copy this code block
           <NewPost 				<<<<<ROUTES HERE, copy this code block
             handleSubmit={handleSubmit}	<<<<<ROUTES HERE, copy this code block
             postTitle={postTitle}		<<<<<ROUTES HERE, copy this code block
             setPostTitle={setPostTitle}	<<<<<ROUTES HERE, copy this code block
             postBody={postBody}		<<<<<ROUTES HERE, copy this code block
             setPostBody={setPostBody}		<<<<<ROUTES HERE, copy this code block
           />					<<<<<ROUTES HERE, pasted here
         <Route exact path="/post"		<<<<<ROUTES HERE, pasted here
           <NewPost 				<<<<<ROUTES HERE, pasted here
             handleSubmit={handleSubmit}	<<<<<ROUTES HERE, pasted here
             postTitle={postTitle}		<<<<<ROUTES HERE, pasted here
             setPostTitle={setPostTitle}	<<<<<ROUTES HERE, pasted here
             postBody={postBody}		<<<<<ROUTES HERE, pasted here
             setPostBody={setPostBody}		<<<<<ROUTES HERE, pasted here
           />					<<<<<ROUTES HERE, pasted here
         </Route>	
         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
     </div>
  )

pasted above
remove the exact
change the path to edit				/post -->  /edit
the add id parameter right after edit
change <NewPost to <EditPost

         <Route exact path="/post"
         <Route path="/post"
         <Route path="/edit"
         <Route path="/edit/:id"
           <NewPost
           <EditPost


now we need to pass in all the props we need
we need posts={posts}
instead of handleSubmit it will be handleEdit
instead of postTitle it will be editTitle
instead of setPostTitle it will be setEditTitle
instead of postBody it will be editBody
instead of setPostBody it will be setEditBody 		v06.34.10

thus we have
           <EditPost
             posts={posts}			// we need posts={posts}
             handleEdit={handleEdit}		// instead of handleSubmit it will be handleEdit
             editTitle={editTitle}		// instead of setPostTitle it will be setEditTitle
             setEditTitle={setEditTitle}	// instead of setPostTitle it will be setEditTitle
             editBody={editBody}		// instead of postBody it will be editBody
             setEditBody={setEditBody}		// instead of setPostBody it will be setEditBody
           />	

now we have all the props being passed in 
and the correct routing in

now we need to create the link and then have a way to go to that route	v06.34.19

lets go back to our EditPost component to complete something v06.34.51
here we have the if editTitle exists
which is essentially asking if 
(1) the post exists (as a post will have the editTitle field)

            {editTitle &&				// cut } from here and paste below in this code block

but 
(2) if the post does NOT exist (and this poosibility exists as the page could be requested
    but it in fact does not exist)
    then we need to go ahead and update this from 	{! postTitle && 	to	{! editTitle &&

if we do not have a title (ie the post does not exist)
then we need to pass in our Post Not Found text which is where
we use the react router link to go back to the home page

    return (
        <main className="NewPost">			
            {editTitle &&				// cut } from here and paste below in this code block
                <>
                    <h2>Edit Post</h2>
                    <form className="newPostForm" onSubmit=>{(e) => e.preventDefault()}>
	                <label htmlFor="postTitle">Title:</label>
	                <input
	                    id="postTitle"
       	                    type="text"
	                    required
	                    value={editTitle}
	                    onChange={(e) => setEditTitle(e.target.value)}
     	                />
	                <label htmlFor="postBody">Post:</label>
	                <textarea
	                    id="postBody'
	                    required
	                    value={editBody} 
	                    onChange={(e) => setEditBody(e.target.value)}
	                />
                        <button type="submit" onClick={() => handleEdit(post.id)} \>Submit</button>
                    </form>
                </>
           }
           {!editTitle &&			// if we do not have a title (ie the post does not exist)
                <>
                    <h2>Post Not Found</h2>			// then we need to pass in our Post Not Found text
                    <p>Well, that's disappointing.</p>		//then we need to pass in our Post Not Found text
                    <p>
                        <Link to='/'>Visit Our Homepage</Link>	//we use react router link to go back to the home page
                    </p>
                </>
     )
}

export default EditPost


so now our edit post component				v06.35.05
we have completed the edit component (see EditPost.js)

and back in App.js we have completed the routing in App.js	v06.35.11

so now that we have the routing, we just need to create a link to the EditPage

Note that we already have a Delete button on the PostPage 
so this PostPage could be a good place to add another button 
to allow an Edit						v06.35.23

so go to the PostPage.js and directly above the button tag			<<<<<<<<<<<<

import { useParams, Link } from "react-router-dom";

const PostPage = ({ posts, handleDelete }) => {
    const { id } = useParams();
    const post = posts.find(post => (post.id).toString() === id);
    return (
      <main className="PostPage">
          <article className="post">
              {post && 
                  <>
                      <h2>{post.title}</h2>
                      <p className="postDate">{post.datetime}</p>
                      <p className="postBody">{post.body}</p>
		      <Link							<<<<<<<<<<<<HERE
                      <button onClick={() => handleDelete(post.id)}>		<<<<<<<<<<<<HERE
                          Delete Post
                      </button>
                  </>
              }
          </article>
      </main>
    )
}

export default PostPage


add the code here
use Link tag
which we already imported above from react-router		Link to
set this to 							=
add a template literal						{``}
and pass in the /edit path					/edit/
and here this template literal will be  			${post.id}		v06.35.45

		      // here  <Link
                      <button onClick={() => handleDelete(post.id)}>

		      <Link
		      <Link to=
		      <Link to={}
		      <Link to={``}
		      <Link to={`/edit/`}
		      <Link to={`/edit/${}`}
		      <Link to={`/edit/${post.id}`}

_____v06.35.23

lets finish off the beginning of the Link tag	
by typing > VSCode automatically gives you the ending tag

		      <Link to={`/edit/${post.id}`}></Link>

inside the link we add text for the button		<button>
VSCode automatically adds the ending tag		</button> 
give the button a classname 				editButton
to differentiate if from the delete button		className="editButton"
add text on the Button					Edit Post

		      <Link to={`/edit/${post.id}`}><button></button></Link>
		      <Link to={`/edit/${post.id}`}><button className=""></button></Link>
		      <Link to={`/edit/${post.id}`}><button className="editButton"></button></Link>
		      <Link to={`/edit/${post.id}`}><button className="editButton">Edit Post</button></Link>

so far we have 

                      <h2>{post.title}</h2>
                      <p className="postDate">{post.datetime}</p>
                      <p className="postBody">{post.body}</p>
		      <Link to={`/edit/${post.id}`}><button className="editButton">Edit Post</button></Link>
                      <button onClick={() => handleDelete(post.id)}>
                          Delete Post
                      </button>

now lets give the deleteButton a className as well	className="deleteButton"

                      <button onClick={() => handleDelete(post.id)}>
                      <button clasName="deleteButton" onClick={() => handleDelete(post.id)}>

v06.36.18

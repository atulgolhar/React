today we are not adding any new functionality to the blog application
instead we refactor

we start with App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import EditPost from './EditPost';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';
import useWindowSize from './hooks/useWindowSize';		
import useAxiosFetch from './hooks/useAxiosFetch';

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');
  const [editBody, setEditBody] = useState('');
  const history = useHistory();
  const { width } = useWindowSize();

  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

  useEffect(() => {
    setPosts(data);  
  }, [data])

  useEffect(() => {
    const filteredResults = posts.filter(post => 
      ((post.body).toLowerCase()).includes(search.toLowerCase())
      || ((post.title).toLowerCase()).includes(search.toLowerCase()));

    setSearchResults(filterResults.reverse());
  }, [posts, search])							

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  return (
     <div className="App">
       <Header title="React JS Blog" width={width} />
       <Nav search={search} setSearch={setsearch} />
       <Switch>
         <Route exact path="/">
           <Home 				<<<<<<<<<<<<HERE
             posts={searchResults} 		<<<<<<<<<<<<HERE
             fetchError={fetchError}		<<<<<<<<<<<<HERE
             isLoading={isLoading}		<<<<<<<<<<<<HERE
           />					<<<<<<<<<<<<HERE
         </Route>
         <Route exact path="/post">
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         </Route>
         <Route path="/edit/:id">
           <EditPost
             posts={posts}		
             handleEdit={handleEdit}	
             editTitle={editTitle}	
             setEditTitle={setEditTitle}	
             editBody={editBody}	
             setEditBody={setEditBody}	
           />	

         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
     </div>
  )
}


v07.17.15

we will refactor useContext instead of drilling props down
as becomes cumbersome, see current App.js so 
1) refactor to create much neater App.js file
2) be able to subscribe to use the Context API and use useContext hook to pull in the info
v07.18.07

create new folder called 					context
create new file inside context folder called			DataContext.js

note you can have more than 1 Context per application
today we just create 1 to explain how it works
but imagine a 
User section where user entered information
Completely seperate Context to manage state

start with an import statement			
createContext from react
add import useState and useEffect as well

file DataContext.js 

import {}
import { createContext }
import { createContext } from 'react';
import { createContext, useState, useEffect } from 'react';

now define our DataContext
set this equal to createContext that we just imported
to start lets include an empty object {} inside createContext()

const DataContext
const DataContext = createContext
const DataContext = createContext()
const DataContext = createContext({});

the DataProvider will provide the data to our different components
then we export const DataProvider = ()
we need an arrow function here
inside the DataProvider are destructured children
destructured children refer to the component that within the DataProvider		({ children })
thus allowing the data to be available to the children of the DataProvider		({ children })
so now that we have defined the DataProvider lets add a return statement inside it	return ()

export 
export const DataProvider = () => {}
export const DataProvider = ({ children }) => {}
export const DataProvider = ({ children }) => {			

}

export const DataProvider = ({ children }) => {
    return ()
}

now we have JSX code					<
so then inside the return statement, we have
a DataContext.Provider					<DataContent.Provider
and then here we have a value={{}}
note we use 2 curly braces {{}}					v07.19.46
add extra line and then close out greater than symbol >

    return (
        <DataContent.Provider value={{
        //  put different values here, before passed as props, 
        //  data is now requested by useContext hook, pass through DataContext.Provider
        }}>
    )


now lets finish this function
add {children} in the JSX, 
then after children we closeout </DataContext.Provider> in the JSX
now save
add export default DataContext;

    return (
        <DataContent.Provider value={{

        }}>
            {children}
        </DataContext.Provider>
    )

}

export default DataContext;


so skeleton file DataContext.js is
we will need to move state and anything else we want here
that will provide here into the DataProvider 


import { createContext, useState, useEffect } from 'react';

const DataContext = createContext({});

export const DataProvider = ({ children }) => {
    return (
        <DataContent.Provider value={{

        }}>
            {children}
        </DataContext.Provider>
    )

}

export default DataContext;


Lets go back to the App.js	v07.20.47


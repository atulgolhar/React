we have App.js
Need to 
create data folder 			data
create new file db.json			db.json

inside db.json
we can add and modify data from within the App component
right now we have a static state for posts 
these are objects inside an array
(ie post data is hard coded inside App.js 
so any changes to posts then reload App will result in 
default hardcoded posts remaining inside App).
Need to make post state dynamic (thus eliminate hardcoding).
We cut hardcoded posts from App.js and paste into db.json file
and need to add quotes some elements.

so here we have an object		{
we have given it the name "posts"	"posts":
key-value so the value for this property is the array		[
notice that each of the json objects are within quotes ""
vs no quotes in the hard coded json data in the App component
therefore you need to ensure that you are formatting like this in db.json v06.04.09
now save b/c we have the db.json file inside the data folder

{
    "posts": [
      {
        "id": 1,							added "" to key
        "title": "My First Post"					added "" to key



OLD 
App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home';
import NewPost from './NewPost';
import PostPage from './PostPage';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';

function App() {
  const [posts, setPosts] = useState([
        {
          id: 1,
          title: "My First Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },
        {
          id: 2,
          title: "My 2nd Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },
        {
          id: 3,
          title: "My 3rd Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },
        {
          id: 4,
          title: "My 4th Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        }
      ])

  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const history = useHistory();

hardcoded posts code here

function App() {
    const [posts, setPosts] = useState([
        {
          id: 1,							missing "" for key
          title: "My First Post"					missing "" for key
          datetime: "July 01, 2023 11:17:36 AM"				missing "" for key
          body: "Lorem ipsum dolor sit amet consectuor elit."		missing "" for key
        },


db.json properly formated posts here
{
    "posts": [
      {
        "id": 1,							added "" to key
        "title": "My First Post"					added "" to key
        "datetime": "July 01, 2023 11:17:36 AM"				added "" to key
        "body": "Lorem ipsum dolor sit amet consectuor elit."		added "" to key
      },

v06.04.18
now we go back to the App.js file
function App() {
  const [posts, setPosts] = useState([
				     ^ from here onwards for entire array []
        {
          id: 1,
          title: "My First Post"
          datetime: "July 01, 2023 11:17:36 AM"
          body: "Lorem ipsum dolor sit amet consectuor elit."
        },

and replace that with an empty array

  const [posts, setPosts] = useState([])

so we are left with this

  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const history = useHistory();

add the ;
and now this is really all we need to get the json server up and running.  v06.04.34

so now we go to package.json file in file tree

src
.gitignore
package-lock.json
package.json
README.md

now we need to add Axios as a new dependency

go to Chrome
npmjs.com/package/axios
in VSCode, open terminal window 	CONTROL `
type npm i for install axios and -S 
-S is a habit but no longer neededfa

$ npm i axios -S				v06.05.44
Enter

can now see Axios in package.json file as listed dependency
"axios": "^0.21.1",4

close terminal window
open src folder in file tree
add new folder inside src folder
new folder name is		api
new file created 		posts.js

add this code inside blank posts.js file

import axios from 'axios';

now we set the base url 
so we set 
export default axios.create({})
then on seperate line we define the base url property
and we set this to our http local host post 3500	'http://localhost:3500'
port 3500 is where we launch our json server on



export default axios.create()
export default axios.create({})
export default axios.create({

})

export default axios.create({
    baseURL: ''
})

export default axios.create({
    baseURL: 'http://localhost:3500'
});


save
now this is all we need in this file
now axios will continue to use this base url
if you are doing this to take this project live, 
then you would need to change this base url to whatever you
have as a base url for your host

open terminal window  CONTROL `
1st) inside this 1st terminal window we need to launch json server
-p means port
-w means watch

$ npx json-server -p 3500 -w data/db.json			v.06.07.30
Enter
By pressing Enter, this should launch our json server instance

2nd) lets launch react app in another terminal window

To open 2nd terminal window, click + sign 
and now you can see terminal window tree on right 
where we have two bash terminal windows running
In this 2nd terminal window, we launch our react app

$ npm start	

now notice that once we get this started, we should not see any posts
b/c we changed the state. (ie removed hardcoded posts from App.js file).
but then the react will show any changes we make as we add axios into 
our Application.

Chrome browser shows rendered app
Now our application is loaded with 'No posts to display.' and
this is what we expected since we cleared out the static state.
Now resize window so we can see VSCode on left 1/2 of screen and 
rendered app on Chrome on right 1/2 of screen.
Thus we can work on VSCode on left and view app on right.
Close terminal windows but note that they continue to run.
We can open the terminal windows at any time.
Open file tree CONTROL B

Go to App.js file
Hide file tree

now we need to import our API
import api from './api/posts';
so now we have imported the API and we can use it inside the Application

App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';			<<<<<<<<<<<<<<<<<<<<<<<NEW  v06.09.19

so now we have imported the API and can use it within the Application

now within App.js underneath the useHistory line (line 20)
  const history = useHistory(); line
press return and start another useEffect
this useEffect is where we will fetch our data

we only want this fetch to happen at load time 
so the depedency should be an empty array 		[]
now inside this useEffect we need to define our fetch function		const fetchPosts
this should be an async function					async () => {}

now inside the async function we have a try catch finally block		try {} catch ()
inside the catch we catch any possible error 				catch (err)
// continue explanation below

  useEffect()								v06.09.50
  useEffect(() => {})
  
  useEffect(() => {

  }, [])

  useEffect(() => {
    const fetchPosts = 
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {}
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
      } catch ()
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
      } catch (err)
    }
  }, [])

// continue explanation
we need to define how to use axios
so we define a response 					const response = 
we set the response equal to await api.		
remeber api. is the axios instance we are importing		api.

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.
      } catch (err)
    }
  }, [])

and now we use get						api.get
this is where axios becomes very easy to understand b/c
we actually use the verbage the words that we could in a CRUD operation
for api usage so such as http uses get post put delete patch and a few others
but we are going to only use the basic CRUD operations
so get is our read operation in CRUD
so now we just need to say what endpoint we want with that base url
this application only has 1 endpoint which is /posts		api.get('/posts');
(--> ie get the Posts)
so now we need to define this
and note that this (ie axios) replaces fetch
and so what is so nice about axios instead of fetch are (1) (2) 
(1) axios automatically creates the json so we dont need the 
2nd step to define data and then set it equal to response.json
(2) axios will automatically catch the errors when the errors are not
in the 200 range of http responses					v06.11.50
so before where we would have said 
      if (!response.ok)
if the response.ok was false
we dont have to do this b/c axios will 
automatically catch anything outside of the 200 range
so what we can do is
set our state with setPosts()					setPosts()
(--> ie setting Posts state)

b/c if we get to this point then *** automatically an error has not occurred *** 
and thus we know its already in the 200 range
we put our data into the (response.data)			setPosts(resposne.data)

note that some you see might say
if we have a resposne
and if we the data
  if (response && response.data)
and you can do this to be extra careful
we dont do that here b/c we know we have a response in the 200 range
and if we have a 200 range response then we know that our json server
is absolutely going to send data back
Also, if you are working with someone who is working the backend, then
you might know already know that you will be getting a response
in that 200 range
But if not, then this is how you could check for this to make sure you
have a response.

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get
      } catch (err)
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
      } catch (err)
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts()					<<<<<<<<<<<<setPosts()
      } catch (err)
    }
  }, [])

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)				<<<<<<<<<<<<setPosts(response.data)
      } catch (err)			<<<<<<<<<<<<<<<<<<<<<see below
    }
  }, [])


v06.13.23

Need to capture backend API reponses
sometimes they will be 200 responses, non-200 (404) responses, or no response at all

now axios catches those errors
// Not in the 200 response range
this is copied pasted directly from axios documentation
axios will log all these errror categories (and more): data, status, headers

      } catch (err) {
        // Not in the 200 response range
          console.log();
          console.log();
          console.log();

      } catch (err) {
        // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);

so if your backend was sending a message,
        console.log(err.response.data);

then you would receive the message like this
        console.log(err.response.data.message);

it will just depend on what the backend is delivering
when its not in the 200 range, so you must know (be aware) of
what you are dealing with (ie aware of the api that you are working with)
to actually know what property to pull out of that data

you can also do this for the status and the headers

but axios will also catch other possible errors so we need to add code for this
this means we have an error and its response property
        if (err.response) {}

ie errors in:
- 200 range vs					// no error 
- some other # range vs 			// yes errors but Not in the 200 response range
- undefined					// yes error but its an undefined error

      } catch (err) {
        if (err.response) {
          // Not in the 200 response range
          // add code here			console.log(err.response.data);
          // add code here			console.log(err.response.status);
          // add code here			console.log(err.response.headers);
        } else {
          // Undefined error
          // add code here 			console.log(``);		// template literal
          // add code here 			console.log(`Error:`);
          // add code here 			console.log(`Error: ${}`);
          // add code here 			console.log(`Error: ${err.message}`);
        }


  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)
      } catch (err) {
        if 
          // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);
      } else {
          console.log(`Error: ${err.message}`)		// template literal		v06.15.00
      }
    }
  }, [])


so if we get to this
we know we did not get any response at all from the backend API

         console.log(`Error: ${err.message}`)		// template literal		v06.15.00

this is directly from the axios documentation
and so axios handles those errors very well
and we can pull out extra data if we need to		v06.15.33

now our function for fetchPosts is now defined
but we still need to call fetchPosts() inside useEffect <<<<<<<<<<<<<<<<<<<<<<<<HERE

  useEffect(() => {
    const fetchPosts = async () => {
      try { 
        const response = api.get('/posts');
        setPosts(response.data)
      } catch (err) {
        if 
          // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);
      } else {
          console.log(`Error: ${err.message}`)		// template literal		v06.15.00
      }
    }

    fetchPosts(); 			<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<HERE
  }, [])


save
now we can see our posts in the rendered Chrome app v06.15.46 --> 06.15.48
our development server loaded the page as soon as we saved our changes

Now we can make a New Post on the Post page in our application

So now the next thing we need to adjust in our application is the handleSubmit function
v06.16.23
this is the C in CRUD		Create a new post

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody }; <<<<New Post created here so add line
    // add C code here
    const allPosts = [...posts, newPost];
    setPosts(allPosts);
    setPostTitle('');
    setPostBody('');
    history.push('/');
  }

add try{}
delete ending curly brace
Now for all lines after this (const allPosts, setPosts(allPosts), setPostTitle, setPostBody, history,push)
all these lines should be inside the try block 
b/c they are for New Post creation
Add } curly brace at end of this try segment 
b/c we dont want to make any of those lines
happen if our try {} block fails

    // add C code here
    try {}

    try {
      const allPosts = [...posts, newPost];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    }

Now catch the error					catch (err) {
add console.log with template literal			console.log(`Error: ${err.message}`)
so this way, at least we know that we are grabbing the message and logging it
ie we are acknowledging that we might get an error in this development application

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody }; <<<<New Post created here so add line
    // add C code here
    const allPosts = [...posts, newPost];		<<<<MOVE FROM HERE
    setPosts(allPosts);					<<<<MOVE FROM HERE
    setPostTitle('');					<<<<MOVE FROM HERE
    setPostBody('');					<<<<MOVE FROM HERE
    history.push('/');					<<<<MOVE FROM HERE
    try {
      const allPosts = [...posts, newPost];		<<TO HERE
      setPosts(allPosts);				<<TO HERE
      setPostTitle('');					<<TO HERE
      setPostBody('');					<<TO HERE
      history.push('/');				<<TO HERE
    } catch (err) {					<<<<<<<<<<<<<<<<<<<catch err
        console.log(`Error: ${err.message}`);		<<<<<<<<<<<<<<<<<<<err.message
    }
  }


so far we have
but remember this was focused on a newPost
so we address this now. So far we have

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody }; <<<<New Post created here so add line
    try {
      const response 					<<<<<<<<<HERE
      const allPosts = [...posts, newPost];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

Now in the try block, we need to define a response
so const response is equal to await api.
but now we are posting a new blog post so its 	api.post
Before we used api.get			const response = api.get('/posts');
Now we use api.post			const response = api.post
We use api.post b/c we are posting a new blog post
Then we need to define the endpoint 	  	('/posts'
then we pass in the new post			         , newPost);

      const response
      const response = await
      const response = await api.
      const response = await api.post()
      const response = await api.post('/posts')
      const response = await api.post('/posts', newPost);

so now we have

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody }; <<<<New Post created here so add line
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, newPost];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

Now after we added the await api.post code
we need to see where we are
we need to now alter allPosts b/c we just added a new post but didnt yet change allPosts
we need to change newPost to response.data
      const response = await api.post('/posts', newPost);

note that response.data should be the same as the newPost

      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, newPost];
				  ^^^^^^^
why? b/c it should be just the api sending us the data back into response from line above it

      const allPosts = [...posts, newPost];			// OLD
      const allPosts = [...posts, response.data];		// NEW
				  ^^^^^^^^^^^^^

so what happens is we try to define response as response ingests the api newPost response
then that newPost is the same as response.data
so we just use response.data  

    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, newPost];


      const allPosts = [...posts, newPost];
				  ^^^^^^^
      const allPosts = [...posts, response.data];
				  ^^^^^^^^^^^^^

so we now have
response.data instead of newPost
then we setPosts to allPosts
we still empty out our controlled form that has the Title and the Body
and then we use history.push to go back to the actual blog to 
see the full list in the blog feed thus we now now have an updated history
and nothing else changes
so we just use axios to
(1) send the new data 
      const response = await api.post('/posts', newPost);
(2) then we update the state with the actual response we get from the api
    thus we extract the .data out of the response

thus updated code is

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];		// response.data is the newPost data
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

now save
notice that we have an error
b/c we added await but not add async to this as can can not await without async

  const handleSubmit = (e) => {
  const handleSubmit = async (e) => {

now save again
App renders ok
Lets make a New Post with the title: Test Post for Tutorial
add Body text to the New Post
Enter
Rendered app now shows that Test Post in the Blog. It works.		v06.19.40
start with this

  const handleDelete = (id) => {
    const postsList = posts.filter(post => post.id !== id);
    setPosts(postsList);
    history.push('/');
  }


add async
Add try block
Everything that was there before will now be inside of try block
Then after try block we add the same catch block as used in handleSubmit
v06.20.17


  const handleDelete = async (id) => {					<<<<<<<add async
    try {								<<<<<<<add try block
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {							<<<<<<<add catch block
        console.log(`Error: ${err.message}`);
    }

  }


v06.20.17

now inside to try, we may not get a response right away sp 
we need to await a response				await 
api.delete call delete					api.delete()
use a template literal ``				(``)
we pass in the endpoint /posts				(`/posts/`)
we also need the specific post id 			${id}

  const handleDelete = async (id) => {
    try {
      await api.delete
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

      await api.delete
      await api.delete()
      await api.delete(``)
      await api.delete(`/posts/`)
      await api.delete(`/posts/${}`)
      await api.delete(`/posts/${id}`)

so we now have 

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }


save
Now in Chrome App, go to the Test Post page and try to delete the Post
now everything seems to be working as it should for the delete operation
So far we have Create, Read and Delete completed
and now for the more complex of the 4 operations is Update

App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';

  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  return (
     <div className="App">
       <Header title="React JS Blog"/>
       <Nav search={search} setSearch={setsearch} />
       <Switch>		
         <Route exact path="/"
           <Home posts={posts}/>
         </Route>
         <Route exact path="/post"
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
           <NewPost />
         </Route>	
         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
     </div>
  )
}


v06.21.08

lets create the function
call it handleEdit b/c we are going to edit the post
add it just above handleDelete
its an anonymous function, need the id of the post
this will be async
now inside the handleEdit, we will need some new state	v06.21.30
take postTitle and postBody lines, copy and paste then change
to editTitle and editBody
thus postTitle setPostTitle becomes editTitle setEditTitle
thus postBody setPostBody becomes editBody setEditBody

  const handleEdit
  const handleEdit = async						v06.21.13
  const handleEdit = () => {}
  const handleEdit = (id) => {}
  const handleEdit = async (id) => {}

  const handleEdit = async (id) => {

  }


function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');		<<<<<DULPLICATE THIS FOR editTitle, editBody
  const [postBody, setPostBody] = useState('');
  const history = useHistory();

  const [postTitle, setPostTitle] = useState('');		<<<<<DULPLICATE THIS FOR editTitle, editBody
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');		<<<<<DULPLICATE THIS FOR editTitle, editBody
  const [editBody, setEditBody] = useState('');

so we have 

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');		<<<<<
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');		<<<<<
  const [editBody, setEditBody] = useState('');
  const history = useHistory();

so now we have editTitle editBody setEditTitle setEditBody
and we use those in our function for handleEdit
we start with needing the datetime and newPost lines from handleSubmit
so first lets copy those 
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
then paste into handleEdit
datetime will not change
newPost will change to updatedPost
and instead of postTitle, we have editTitle
and instead of postBody, we have editBody
why change these? b/c these will be controlled form where we make those edits
so we need to pieces of controlled state as well to make those edits

  const handleEdit = async (id) => {

  }

  const handleEdit = async (id) => {
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
  }


    const newPost = { id, title: postTitle, datetime, body: postBody };		<<<<postTile, postBody  OLD
    const updatedPost = { id, title: editTitle, datetime, body: editBody };	<<<<editTitle, editBody NEW


so now we have

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
  }

now we can start the try {} block  				v06.22.47
copy catch block from above
inside the try block
start with a const response				const response
set that equal to await					= await 
call our api and now we call .put()				api.put()
instead of put, 
we could use patch if we were updating specific fields
but here we are replacing the entire post
inside the put, we put in the endpoint (`/posts/`)			(`/posts/`)
now we need to be specific to the id of the post using ${id}		(`/posts/${id}`)
after this we pass in our new data which is the updatedPost		(`/posts/${id}`, updatedPost);

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
    try{
      const response		<<<<<<<<<<<<<<<<<<ADD HERE
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

      const response = await 
      const response = await api.put()
      const response = await api.put(`/posts/`)
      const response = await api.put(`/posts/${id}`)
      const response = await api.put(`/posts/${id}`, updatePost);

so now we have

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
    try{
      const response = await api.put(`/posts/${id}`, updatePost);
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

so now we have a response back from axios and the backend API
we use setPosts() here 
but this is a little more complex than we did earlier when 
we just send in all the posts 
      const allPosts = [...posts, response.data];
      setPosts(allPosts);		<<<<<<<<<<<<<<<< simple version
its more complex then the handleSubmit version b/c we need to use map
      setPosts(posts.map)
why?
before all we did was send in the posts 
now we need to use map
b/c if we dont then we are creating an array of old and 
then sending in the new posts as well
key is to eliminate the old posts and just add the new info

so with map
we have each post iterated thru		      		(post => )
map will create a new array by checking 
the post.id strictly equals the new id we passed in	=> post.id === id ))
then ternary statement					? )) 
if true then within this expression {}			{}
lets use the ...response.data				{ ...response.data}
note that the response.data is the new post information
and so if the id is equal to the post id passed in
and if not :						:
then just pass in the post as it is			post

so all this means that only where the post ids match 	post.id === id
is when we pass in the new data				? { ...response.data }
so note that the updatedPost is the same as the destructured { ...response.data }
so this will update our post state 			;

      setPosts(posts.map)
      setPosts(posts.map(post => post.id === id ))
      setPosts(posts.map(post => post.id === id ? ))
      setPosts(posts.map(post => post.id === id ? {} ))
      setPosts(posts.map(post => post.id === id ? { ...response.data } ))
      setPosts(posts.map(post => post.id === id ? { ...response.data } : ))
      setPosts(posts.map(post => post.id === id ? { ...response.data } : post))
      setPosts(posts.map(post => post.id === id ? { ...response.data } : post));

so now we have  		v06.25.02

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
    try{
      const response = await api.put(`/posts/${id}`, updatePost);
      setPosts(posts.map(post => post.id === id ? { ...response.data } : post));  <<<<<<<<<<<<<<<NEW
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

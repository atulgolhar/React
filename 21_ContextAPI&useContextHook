today we are not adding any new functionality to the blog application
instead we refactor

we start with App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import EditPost from './EditPost';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';
import useWindowSize from './hooks/useWindowSize';		
import useAxiosFetch from './hooks/useAxiosFetch';

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');
  const [editBody, setEditBody] = useState('');
  const history = useHistory();
  const { width } = useWindowSize();

  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

  useEffect(() => {
    setPosts(data);  
  }, [data])

  useEffect(() => {
    const filteredResults = posts.filter(post => 
      ((post.body).toLowerCase()).includes(search.toLowerCase())
      || ((post.title).toLowerCase()).includes(search.toLowerCase()));

    setSearchResults(filterResults.reverse());
  }, [posts, search])							

  const handleSubmit = async (e) => {							added async
    e.preventDefault();
    const id = posts.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  return (
     <div className="App">
       <Header title="React JS Blog" width={width} />
       <Nav search={search} setSearch={setsearch} />
       <Switch>
         <Route exact path="/">
           <Home 				<<<<<<<<<<<<HERE
             posts={searchResults} 		<<<<<<<<<<<<HERE
             fetchError={fetchError}		<<<<<<<<<<<<HERE
             isLoading={isLoading}		<<<<<<<<<<<<HERE
           />					<<<<<<<<<<<<HERE
         </Route>
         <Route exact path="/post">
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         </Route>
         <Route path="/edit/:id">
           <EditPost
             posts={posts}		
             handleEdit={handleEdit}	
             editTitle={editTitle}	
             setEditTitle={setEditTitle}	
             editBody={editBody}	
             setEditBody={setEditBody}	
           />	

         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
     </div>
  )
}


v07.17.15

we will refactor useContext instead of drilling props down
as becomes cumbersome, see current App.js so 
1) refactor to create much neater App.js file
2) be able to subscribe to use the Context API and use useContext hook to pull in the info

v07.18.07

Create new folder called 					context
Create new file inside context folder called			DataContext.js

note you can have more than 1 Context per application
today we just create 1 to explain how it works
but imagine a 
User section where user entered information
Completely seperate Context to manage state

start with an import statement			
createContext from react
add import useState and useEffect as well

file DataContext.js 

import {}
import { createContext }
import { createContext } from 'react';
import { createContext, useState, useEffect } from 'react';

now define our DataContext
set this equal to createContext that we just imported
to start lets include an empty object {} inside createContext()

const DataContext
const DataContext = createContext
const DataContext = createContext()
const DataContext = createContext({});

the DataProvider will provide the data to our different components
then we export const DataProvider = ()
we need an arrow function here
inside the DataProvider are destructured children
destructured children refer to the component that within the DataProvider		({ children })
thus allowing the data to be available to the children of the DataProvider		({ children })
so now that we have defined the DataProvider lets add a return statement inside it	return ()

export 
export const DataProvider = () => {}
export const DataProvider = ({ children }) => {}
export const DataProvider = ({ children }) => {			

}

export const DataProvider = ({ children }) => {
    return ()
}

now we have JSX code					<
so then inside the return statement, we have
a DataContext.Provider					<DataContent.Provider
and then here we have a value={{}}
note we use 2 curly braces {{}}					v07.19.46
add extra line and then close out greater than symbol >

    return (
        <DataContent.Provider value={{
        //  put different values here, before passed as props, 
        //  data is now requested by useContext hook, pass through DataContext.Provider
        }}>
    )


now lets finish this function
add {children} in the JSX, 
then after children we closeout </DataContext.Provider> in the JSX
now save
add export default DataContext;

    return (
        <DataContent.Provider value={{

        }}>
            {children}
        </DataContext.Provider>
    )

}

export default DataContext;


so skeleton file DataContext.js is
we will need to move state and anything else we want here
that will provide here into the DataProvider 

DataContext.js

import { createContext, useState, useEffect } from 'react';

const DataContext = createContext({});

export const DataProvider = ({ children }) => {
    return (
        <DataContent.Provider value={{

        }}>
            {children}
        </DataContext.Provider>
    )

}

export default DataContext;


in App.js, we need to import our DataProvider
import { DataProvider } from './context/DataContext';
and now we can use the DataProvider to 
provide data to any of these components in the JSX 
such as 
          <Home 			
             posts={searchResults} 	
             fetchError={fetchError}	
             isLoading={isLoading}	
           />			
         </Route>
         <Route exact path="/post">
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         </Route>

but this JSX is still large as we have many props that we are drilling down
we will clean this up 
Now we want to put the DataProvider (as a wrapper) around all of the components
and then the components within can subscribe at will to the DataProvider
Now the DataProvider is a parent to all the components within (ie children)
And so now the data that comes from the DataProvider will be available to all the
components within if we choose to pull that data in using the useContext hook
(need to tab over all those lines)


So we have App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import EditPost from './EditPost';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';
import useWindowSize from './hooks/useWindowSize';		
import useAxiosFetch from './hooks/useAxiosFetch';
import { DataProvider } from './context/DataContext';		<<<<<<<<<<<<<<<<<<HERE

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');
  const [editBody, setEditBody] = useState('');
  const history = useHistory();
  const { width } = useWindowSize();

  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

  useEffect(() => {
    setPosts(data);  
  }, [data])

  useEffect(() => {
    const filteredResults = posts.filter(post => 
      ((post.body).toLowerCase()).includes(search.toLowerCase())
      || ((post.title).toLowerCase()).includes(search.toLowerCase()));

    setSearchResults(filterResults.reverse());
  }, [posts, search])							

  const handleSubmit = async (e) => {							added async
    e.preventDefault();
    const id = posts.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  return (
     <div className="App">
       <DataProvider>					<<<<<<<<<<<<<<<HERE
       <Header title="React JS Blog" width={width} />
       <Nav search={search} setSearch={setsearch} />
       <Switch>
         <Route exact path="/">
           <Home 			
             posts={searchResults} 	
             fetchError={fetchError}	
             isLoading={isLoading}	
           />			
         </Route>
         <Route exact path="/post">
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         </Route>
         <Route path="/edit/:id">
           <EditPost
             posts={posts}		
             handleEdit={handleEdit}	
             editTitle={editTitle}	
             setEditTitle={setEditTitle}	
             editBody={editBody}	
             setEditBody={setEditBody}	
           />	

         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
       </DataProvider>   	<<<<<<<<<<<<<<<<<<<<<<<<HERE
     </div>
  )
}



Now lets start moving all those lines of state over to the DataContext.js component
while we still leave it here as well so that we can keep the app working during the 
transition as we refactor.

Lets grab everything after the components here and move them to the DataContext.js file
and copy into DataContext.js below


So we have App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import EditPost from './EditPost';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';	<<<<<<<<<<<<<<MOVE (ie copy and paste for now)
import { useState, useEffect } from 'react';			<<<<<<<<<<<<<<MOVE (ie copy and paste for now) 
import { format } from 'date-fns';				<<<<<<<<<<<<<<MOVE (ie copy and paste for now)
import api from './api/posts';					<<<<<<<<<<<<<<MOVE (ie copy and paste for now)
import useWindowSize from './hooks/useWindowSize';		<<<<<<<<<<<<<<MOVE (ie copy and paste for now)
import useAxiosFetch from './hooks/useAxiosFetch';		<<<<<<<<<<<<<<MOVE (ie copy and paste for now)
import { DataProvider } from './context/DataContext';

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');
  const [editBody, setEditBody] = useState('');
  const history = useHistory();
  const { width } = useWindowSize();

  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

  useEffect(() => {
    setPosts(data);  
  }, [data])

  useEffect(() => {
    const filteredResults = posts.filter(post => 
      ((post.body).toLowerCase()).includes(search.toLowerCase())
      || ((post.title).toLowerCase()).includes(search.toLowerCase()));

    setSearchResults(filterResults.reverse());
  }, [posts, search])							

  const handleSubmit = async (e) => {								added async
    e.preventDefault();
    const id = posts.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  const handleEdit = async (id) => {
    const newPost = { id, title: postTitle, datetime, body: postBody };
    const updatedPost = { id, title: editTitle, datetime, body: editBody };
    try{
      const response = await api.put(`/posts/${id}`, updatePost);
      setPosts(posts.map(post => post.id === id ? { ...response.data } : post)); 
      setEditTitle('');	
      setEditBody('');	
      history.push('/');	
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  return (
     <div className="App">
       <DataProvider>					<<<<<<<<<<<<<<<HERE
       <Header title="React JS Blog" width={width} />
       <Nav search={search} setSearch={setsearch} />
       <Switch>
         <Route exact path="/">
           <Home 			
             posts={searchResults} 	
             fetchError={fetchError}	
             isLoading={isLoading}	
           />			
         </Route>
         <Route exact path="/post">
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         </Route>
         <Route path="/edit/:id">
           <EditPost
             posts={posts}		
             handleEdit={handleEdit}	
             editTitle={editTitle}	
             setEditTitle={setEditTitle}	
             editBody={editBody}	
             setEditBody={setEditBody}	
           />	

         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
       </DataProvider>   
     </div>
  )
}



DataContext.js

import { createContext, useState, useEffect } from 'react';
import { Route, Switch, useHistory } from 'react-router'dom';	<<<<<<<<<<<<<<paste to here
import { useState, useEffect } from 'react';			<<<<<<<<<<<<<<paste to here
import { format } from 'date-fns';				<<<<<<<<<<<<<<paste to here
import api from './api/posts';					<<<<<<<<<<<<<<paste to here
import useWindowSize from './hooks/useWindowSize';		<<<<<<<<<<<<<<paste to here
import useAxiosFetch from './hooks/useAxiosFetch';		<<<<<<<<<<<<<<paste to here

const DataContext = createContext({});

export const DataProvider = ({ children }) => {
    return (
        <DataContent.Provider value={{

        }}>
            {children}
        </DataContext.Provider>
    )

}

export default DataContext;


Then we can begin cleaning up this file

we can delete the useState, useEffect as we already got that
import { useState, useEffect } from 'react';			<<<<DELETE THIS LINE

we can delete the Route, Switch from line 2
we need to keep useHistory
import { Route, Switch, useHistory } from 'react-router'dom';
import { useHistory } from 'react-router'dom';	

we keep format
import { format } from 'date-fns';				

now when we get to the api, we need to recognize where this file is located
we need to consider where the file is located		v07.22.54
file tree shows  
	src folder
		context folder
			DataContext.js file
so we need to come up thus one dot .
then we need to come up again thus one dot . 	(ie two dots now)

import api from './api/posts';					
import api from '../api/posts';					

for the import hooks statements, its the same logic thus add a dot

import useWindowSize from './hooks/useWindowSize';		
import useAxiosFetch from './hooks/useAxiosFetch';		

import useWindowSize from '../hooks/useWindowSize';		
import useAxiosFetch from '../hooks/useAxiosFetch';		


thus so far we have 
DataContext.js

import { createContext, useState, useEffect } from 'react';
import { useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';				
import api from '../api/posts';					
import useWindowSize from '../hooks/useWindowSize';		
import useAxiosFetch from '../hooks/useAxiosFetch';		

const DataContext = createContext({});

export const DataProvider = ({ children }) => {
    return (
        <DataContent.Provider value={{

        }}>
            {children}
        </DataContext.Provider>
    )

}

export default DataContext;

Next we go back to App.js and grab the rest of the needed info

1 grab all of the state we have 	(ie grab all the useState code lines)

  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');
  const [editBody, setEditBody] = useState('');
  const history = useHistory();
  const { width } = useWindowSize();


2 grab the Axios Fetch		(ie grab the useAxiosFetch)

  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');


3 grab the useEffects as well

  useEffect(() => {
    setPosts(data);  
  }, [data])

  useEffect(() => {
    const filteredResults = posts.filter(post => 
      ((post.body).toLowerCase()).includes(search.toLowerCase())
      || ((post.title).toLowerCase()).includes(search.toLowerCase()));

    setSearchResults(filterResults.reverse());
  }, [posts, search])							


and now inside the DataContext.js file
we add 123 inside the DataProvider
NOTE we also leave that same code if the App.js file as well
Why? to make sure the App.js continues working

456 we can also copy all of the 
4 handleSubmit, 
5 handleEdit, 
6 handleDelete
and copy this 456 into the DataContext.js as well 


DataContext.js

import { createContext, useState, useEffect } from 'react';
import { useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';				
import api from '../api/posts';					
import useWindowSize from '../hooks/useWindowSize';		
import useAxiosFetch from '../hooks/useAxiosFetch';		

const DataContext = createContext({});

export const DataProvider = ({ children }) => {
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<ADD HERE
    return (
        <DataContent.Provider value={{

        }}>
            {children}
        </DataContext.Provider>
    )

}

export default DataContext;


so we have


DataContext.js

import { createContext, useState, useEffect } from 'react';
import { useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';				
import api from '../api/posts';					
import useWindowSize from '../hooks/useWindowSize';		
import useAxiosFetch from '../hooks/useAxiosFetch';		

const DataContext = createContext({});

export const DataProvider = ({ children }) => {
    const [posts, setPosts] = useState([])
    const [search, setSearch] = useState('');
    const [searchResults, setSearchResults] = useState([]);
    const [postTitle, setPostTitle] = useState('');
    const [postBody, setPostBody] = useState('');
    const [editTitle, setEditTitle] = useState('');
    const [editBody, setEditBody] = useState('');
    const history = useHistory();
    const { width } = useWindowSize();

    const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');
 
    useEffect(() => {
        setPosts(data);  
    }, [data])

    useEffect(() => {
        const filteredResults = posts.filter(post => 
            ((post.body).toLowerCase()).includes(search.toLowerCase())
            || ((post.title).toLowerCase()).includes(search.toLowerCase()));

    setSearchResults(filterResults.reverse());
    }, [posts, search])							


    const handleSubmit = async (e) => {								added async
        e.preventDefault();
        const id = posts.length ? posts[posts.length - 1].id + 1 : 1;				added s
        const datetime = format(new Date(), 'MMMM dd, yyyy pp');
        const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
        const response = await api.post('/posts', newPost);
        const allPosts = [...posts, response.data];
        setPosts(allPosts);
        setPostTitle('');
        setPostBody('');
        history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

    const handleEdit = async (id) => {
      const newPost = { id, title: postTitle, datetime, body: postBody };
      const updatedPost = { id, title: editTitle, datetime, body: editBody };
    try{
      const response = await api.put(`/posts/${id}`, updatePost);
      setPosts(posts.map(post => post.id === id ? { ...response.data } : post)); 
      setEditTitle('');	
      setEditBody('');	
      history.push('/');	
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

    const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

    return (
        <DataContent.Provider value={{

        }}>
            {children}
        </DataContext.Provider>
    )

}

export default DataContext;


Note - if you have prior experience with React, then you might question why do this?
this is dumping everything into DataContext.js
We will get more organized later in this course
We can think about efficiency later in this course
Essentially we are taking 123456 (all the code from App.js) and moving it into our DataContext
v07.23.55


now at the bottom we are not providing anything yet
but we will
so now lets scroll down in App.js and the first thing we run across 
is the DataProvider Header title.
We can see the Header is receiving the width prop
as well as the title.
We will leave the title prop here as you can do both
both means (1) pass the prop down as a title
while (2) pulling the width data from the DataContext


  return (
     <div className="App">
       <DataProvider>		
       <Header title="React JS Blog" width={width} />		<<<<<<<<<<<<<<<HERE
       <Nav search={search} setSearch={setsearch} />
       <Switch>
         <Route exact path="/">
           <Home 			
             posts={searchResults} 	
             fetchError={fetchError}	
             isLoading={isLoading}	
           />			
         </Route>


so now v07.24.49 back in the DataContext we see this code

    return (
        <DataContent.Provider value={{

        }}>
            {children}
        </DataContext.Provider>
    )

}

export default DataContext;


we have already defined width above in DataContent.js
on line 19 

    const { width } = useWindowSize();

and now we pass it thru the DataProvider

so lets add width right here
(and if we provide more data then we need a comma after width like this

            width 
            width, moreData1, moreData2, moreData3



        <DataContent.Provider value={{

        }}>

        <DataContent.Provider value={{
            width 
        }}>









Now lets look at the Header.js file
v07.25.07
in order to use width from the DataContext, 
we need to remove width from the destructure here 
(ie from being passed in as a prop) 
so we have

const Header = ({ title, width }) => {
const Header = ({ title }) => {

lets add an import at the top of Header.js
this import will be to pull in useContext
this will be the same format as the other hooks from react
then we also need to import our DataContext that we defined earlier


import { FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';

import {FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';
import { useContext } from 'react';

import {FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';
import { useContext } from 'react';						
import DataContext from './context/DataContext';			<<<<<<<<<<<IMPORT DataContext

so now that we have these, 
we need to define width as are no longer pulling width in as a destructured prop above
const width is set equal to useContext 
from the DataContext
So you can see how if you had more than one DataContext then you can
import it and then pass it in to the useContext hook
and in our case, we want the DataContext so we pass that in thru useContext hook
So notice that we are 
1 no longer passing down width (by prop drilling), instead we are
2 importing it and then defining it near the top of the function here just using the useContext hook

import DataContext from './context/DataContext';			<<<<<<<<<<<IMPORT DataContext
    const { width } = useContext(DataContext);				<<<<<<<<<<pass it in thru useContext hook


const Header = ({ title }) => {

const Header = ({ title }) => {
    const { }

const Header = ({ title }) => {
    const { width }

const Header = ({ title }) => {
    const { width } = useContext();

const Header = ({ title }) => {
    const { width } = useContext(DataContext);				<<<<<<<<<<pass it in thru useContext hook


save 

so now Header.js file looks like this

import { FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';
import { useContext } from 'react';
import DataContext from './context/DataContext';

const Header = ({ title }) => {
    const { width } = useContext(DataContext);

    return (
        <header className="Header">
            <h1>{title}</h1>
            {width < 768 ? <FaMobileAlt />
                : width < 992 ? < FaTabletAlt />
                    : < FaLaptop />}
        </header>
    )
}

export default Header


v07.26.32

For example if grabbing data from 3 additional sources, we might do this

import DataContext from './context/DataContext';			<<<<<<<<<<<IMPORT DataContext
import DataContextTopic1 from './context/DataContextTopic1';		<<<<<<<<<<<IMPORT DataContext
import DataContextTopic2 from './context/DataContextTopic2';		<<<<<<<<<<<IMPORT DataContext
import DataContextTopic3 from './context/DataContextTopic3';		<<<<<<<<<<<IMPORT DataContext


    const { width } = useContext(DataContext);				<<<<<<<<<<pass it in thru useContext hook
    const { dataStream1 } = useContext(DataContextTopic1);		<<<<<<<<<<pass it in thru useContext hook
    const { dataStream2 } = useContext(DataContextTopic1);		<<<<<<<<<<pass it in thru useContext hook
    const { dataStream3 } = useContext(DataContextTopic2);		<<<<<<<<<<pass it in thru useContext hook
    const { dataStream4 } = useContext(DataContextTopic3);		<<<<<<<<<<pass it in thru useContext hook

save

go to the Application
width is still working, icon changes as we resize the screen

ignore the warnings (is assigned a value but never used)
we will switch each component over and then eliminate warnings along the way

now we go back to Header.js

copy these two lines for pasting into every component 
that will useContext(DataContext) subscription

import { useContext } from 'react';
import DataContext from './context/DataContext';


so now looking at the JSX for App.js
we want to eliminate the width
       <Header title="React JS Blog" width={width} />	<<<<<<<<<<<<<<<<<<<<<<HERE
       <Header title="React JS Blog" />			<<<<<<<<<<<<<<<<<<<<<<HERE
then we go to the Nav and it receives Search and setSearch 				<<<<<<
so we save the App and 
open up Nav.js


  return (
     <div className="App">
       <DataProvider>					
       <Header title="React JS Blog" width={width} />	<<<<<<<<<<<<<<<<<<<<<<HERE
       <Nav search={search} setSearch={setsearch} />					<<<<<<
       <Switch>
         <Route exact path="/">
           <Home 			
             posts={searchResults} 	
             fetchError={fetchError}	
             isLoading={isLoading}	
           />			
         </Route>
         <Route exact path="/post">
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         </Route>
         <Route path="/edit/:id">
           <EditPost
             posts={posts}		
             handleEdit={handleEdit}	
             editTitle={editTitle}	
             setEditTitle={setEditTitle}	
             editBody={editBody}	
             setEditBody={setEditBody}	
           />	

         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
       </DataProvider>   
     </div>
  )
}



open up Nav.js
we need to paste those two import statements into Nav.js

import { useContext } from 'react';
import DataContext from './context/DataContext';


we also grab this line from Header.js			v07.27.44
(this line of code uses the Context)

    const { width } = useContext(DataContext);

and put this line into our Nav.js

so now our Nav.js file shows	

import { Link } from 'react-router-dom';				<<<<<<<<<ADDED HERE
import { useContext } from 'react';					<<<<<<<<<ADDED HERE
import DataContext from './context/DataContext';			<<<<<<<<<ADDED HERE

const Nav = ({ search, setSearch }) => {
    const { width } = useContext(DataContext);				<<<<<<<<<ADDED HERE
    return (    
        <nav className="Nav">
            <form className="searchForm" onSubmit={(e) => e.preventDefault()}>
                <label htmlFor="search">Search Posts</label>
	        <input
	            id="search"
	            type="text"
	            placeholder="Search Posts"
	            value={search}
	            onChange={(e) => setSearch(e.target.value)}
            </form> 
            <ul>
                <li><Link to="/">Home</li>
                <li><Link to="/post">Post</li>
                <li><Link to="/about">About</li>
            </ul> 
        </nav>
        </nav>
    )
}

export default Nav

but there is a pattern that emerges from these changes as we 
are no longer destructuring as props but instead 
we insert those props right inside the useContext as we use that hook
then we can eliminate the props here in the function parenthesis  v07.28.16


const Nav = ({ search, setSearch }) => {			// 1st show the code to be changed
    const { width } = useContext(DataContext);	

const Nav = ({ search, setSearch }) => {			// grab search, setSearch
    const { search, setSearch } = useContext(DataContext);

const Nav = () => {
    const { search, setSearch } = useContext(DataContext);


we also see that Home receives searchResults, fetchError and isLoading

  return (
     <div className="App">
       <DataProvider>					
       <Header title="React JS Blog" width={width} />					<<<<<<
       <Nav search={search} setSearch={setsearch} />					<<<<<<
       <Switch>
         <Route exact path="/">
           <Home 			
             posts={searchResults} 							<<<<<<
             fetchError={fetchError}							<<<<<<
             isLoading={isLoading}							<<<<<<
           />			
         </Route>

and now in DataContext.js we need to remember to pass along search and setSearch in the DataContext

        <DataContent.Provider value={{
            width 
        }}>

so adding the additional two terms here

        <DataContent.Provider value={{
            width, search, setSearch,
        }}>


and now we see that Home receives searchResults eventhough
we labeled it as posts
also we need fetchError and isLoading so...

           <Home 			
             posts={searchResults} 							<<<<<<
             fetchError={fetchError}							<<<<<<
             isLoading={isLoading}							<<<<<<
 
...so adding the additional two terms here

        <DataContent.Provider value={{
            width, search, setSearch,
            searchResults, fetchError, isLoading
        }}>

save

now pull up the Home.js component		v 07.29.12


// updated Home.js here
 
import Feed from './Feed';

const Home = ({ posts }) => {
  return (
    <main className="Home">
        {isLoading && <p className="statusMsg">Loading</p>}
        {!isLoading && fetchError && <p className="statusMsg" style={{color: "red"}}>{fetchError}</p>}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={posts} /> : <p className="statusMsg">No posts to display.</p>)}
    </main>
  )
}

export default Home



v 07.29.12 Logic:

We will refactor useContext instead of drilling props down
to avoid cumbersome current App.js

1) refactor to create much neater App.js file
2) be able to subscribe to use the Context API and use useContext hook to pull in the info

Create new folder called 					context
Create new file inside context folder called			DataContext.js

note you can have more than 1 Context per application
today we just create 1 to explain how it works
but imagine a 
User section where user entered information
Completely seperate Context to manage state

start with an import statement			
createContext from react
add import useState and useEffect as well

v07.18.07 LOGIC SUMMARY

in src folder
create new folder called 					context
create new file inside context folder called			DataContext.js

Note you can have more than 1 Context per application, today we just create 1 to explain how it works
but imagine a User section where user entered information and will want completely seperate Context to manage state

import createContext, useState and useEffect from react			import { createContext, useState, useEffect } from 'react';
Define DataContext = createContext({});
export const DataProvider
the DataProvider will provide the data to our different components	= () => {}
Inside DataProvider are destructured children
destructured children refer to the component thats within the DataProvider		({ children })
thus allowing the data to be available to the children of the DataProvider		({ children })
So now that we have defined the DataProvider lets add a return statement inside it	return ()
Inside the return we have JSX code with DataContext.Provider with value
DataContext.Provider contains the different values that 
prior pass down props
now pass thru JSX tag DataContext.Provider via useContext hook, add {children} inside Provider then closing tag
add export default DataContext
so now we have our skeleton file DataContext.js is
inside Provider will be state and anything else we want here thru the DataProvider (ie pass thru vehicle)
in App.js, we need to import our DataProvider		import { DataProvider } from './context/DataContext';
and now we can use the DataProvider to provide data to any of these components in the JSX 

Now put DataProvider (as a Parent wrapper) around all components and "then components within can subscribe at will" 
thus parent to all the components within (ie children)

Now the data that comes from DataProvider will be available to all the
components within IF we choose to pull that data in using the useContext hook

During refactor transition, need to keep app working so leave components in place WHILE SIMULANTEOUSLY
start moving all state over to the DataContext.js component

Grab everything after the components here and move them to the DataContext.js file
Then begin cleaning up this file
delete the useState, useEffect as duplicated 
delete the Route, Switch			import { Route, Switch, useHistory } from 'react-router'dom';
we need to keep useHistory			import { useHistory } from 'react-router'dom';	
we keep format					import { format } from 'date-fns';				

Now when we get to the api, we need to recognize where this file is located in file tree hierarchy
need to come up again thus one dot . 	(ie two dots now)		import api from './api/posts';					
									import api from '../api/posts';
and now inside the DataContext.js file
we add 123 inside the DataProvider
NOTE we also leave that same code if the App.js file as well
Why? to make sure the App.js continues working

456 we can also copy all of the 
4 handleSubmit, 
5 handleEdit, 
6 handleDelete
and copy this 456 into the DataContext.js as well 

Note - if you have prior experience with React, then you might question why do this?
this is dumping everything into DataContext.js
We will get more organized later in this course
We can think about efficiency later in this course
Essentially we are taking 123456 (all the code from App.js) and moving it into our DataContext
v07.23.55

now at the bottom we are not providing anything yet
but we will
so now lets scroll down in App.js and the first thing we run across 
is the DataProvider Header title.

We can see the Header is receiving the width prop as well as the title.
We will leave the title prop here as you can do both
both means (1) pass the prop down as a title
while (2) pulling the width data from the DataContext.Provider

if we provide more data then we need a comma after width like this		ATUL123
            width 
            width, moreData1, moreData2, moreData3

Now lets look at the Header.js file		v07.25.07
in order to use width from the DataContext, we need to remove width from the destructure here 
(ie from being passed in as a prop) 

so we have

const Header = ({ title, width }) => {
const Header = ({ title }) => {

lets add an import at the top of Header.js, this import will be to pull in useContext
this will be the same format as the other hooks from react
then we also need to import our DataContext that we defined earlier


import { FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';

import {FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';
import { useContext } from 'react';

import {FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';
import { useContext } from 'react';						
import DataContext from './context/DataContext';			<<<<<<<<<<<IMPORT DataContext

so now that we have these, 
we need to define width as are no longer pulling width in as a destructured prop above
const width is set equal to useContext 
from the DataContext
So you can see how if you had more than one DataContext then you can
import it and then pass it in to the useContext hook
and in our case, we want the DataContext so we pass that in thru useContext hook
So notice that we are 
1 no longer passing down width (by prop drilling), instead we are
2 importing it and then defining it near the top of the function here just using the useContext hook

import DataContext from './context/DataContext';			<<<<<<<<<<<IMPORT DataContext
    const { width } = useContext(DataContext);				<<<<<<<<<<pass it in thru useContext hook


const Header = ({ title }) => {

const Header = ({ title }) => {
    const { }

const Header = ({ title }) => {
    const { width }

const Header = ({ title }) => {
    const { width } = useContext();

const Header = ({ title }) => {
    const { width } = useContext(DataContext);				<<<<<<<<<<pass it in thru useContext hook


save 

so now Header.js file looks like this

import { FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';
import { useContext } from 'react';
import DataContext from './context/DataContext';

const Header = ({ title }) => {
    const { width } = useContext(DataContext);

    return (
        <header className="Header">
            <h1>{title}</h1>
            {width < 768 ? <FaMobileAlt />
                : width < 992 ? < FaTabletAlt />
                    : < FaLaptop />}
        </header>
    )
}

export default Header


v07.26.32

For example if grabbing data from 3 additional sources, we might do this

import DataContext from './context/DataContext';			<<<<<<<<<<<IMPORT DataContext
import DataContextTopic1 from './context/DataContextTopic1';		<<<<<<<<<<<IMPORT DataContext
import DataContextTopic2 from './context/DataContextTopic2';		<<<<<<<<<<<IMPORT DataContext
import DataContextTopic3 from './context/DataContextTopic3';		<<<<<<<<<<<IMPORT DataContext


    const { width } = useContext(DataContext);				<<<<<<<<<<pass it in thru useContext hook
    const { dataStream1 } = useContext(DataContextTopic1);		<<<<<<<<<<pass it in thru useContext hook
    const { dataStream2 } = useContext(DataContextTopic1);		<<<<<<<<<<pass it in thru useContext hook
    const { dataStream3 } = useContext(DataContextTopic2);		<<<<<<<<<<pass it in thru useContext hook
    const { dataStream4 } = useContext(DataContextTopic3);		<<<<<<<<<<pass it in thru useContext hook

save

go to the Application
width is still working, icon changes as we resize the screen

ignore the warnings (is assigned a value but never used)
we will switch each component over and then eliminate warnings along the way

now we go back to Header.js

copy these two lines for pasting into every component 
that will useContext(DataContext) subscription

import { useContext } from 'react';
import DataContext from './context/DataContext';


so now looking at the JSX for App.js
we want to eliminate the width
       <Header title="React JS Blog" width={width} />	<<<<<<<<<<<<<<<<<<<<<<HERE
       <Header title="React JS Blog" />			<<<<<<<<<<<<<<<<<<<<<<HERE
then we go to the Nav and it receives Search and setSearch 				<<<<<<
so we save the App and 
open up Nav.js


  return (
     <div className="App">
       <DataProvider>					
       <Header title="React JS Blog" width={width} />	<<<<<<<<<<<<<<<<<<<<<<HERE
       <Nav search={search} setSearch={setsearch} />					<<<<<<
       <Switch>
         <Route exact path="/">
           <Home 			
             posts={searchResults} 	
             fetchError={fetchError}	
             isLoading={isLoading}	
           />			
         </Route>
         <Route exact path="/post">
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         </Route>
         <Route path="/edit/:id">
           <EditPost
             posts={posts}		
             handleEdit={handleEdit}	
             editTitle={editTitle}	
             setEditTitle={setEditTitle}	
             editBody={editBody}	
             setEditBody={setEditBody}	
           />	

         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
       </DataProvider>   
     </div>
  )
}



open up Nav.js
we need to paste those two import statements into Nav.js

import { useContext } from 'react';
import DataContext from './context/DataContext';


we also grab this line from Header.js			v07.27.44
(this line of code uses the Context)

    const { width } = useContext(DataContext);

and put this line into our Nav.js

so now our Nav.js file shows	

import { Link } from 'react-router-dom';				<<<<<<<<<ADDED HERE
import { useContext } from 'react';					<<<<<<<<<ADDED HERE
import DataContext from './context/DataContext';			<<<<<<<<<ADDED HERE

const Nav = ({ search, setSearch }) => {
    const { width } = useContext(DataContext);				<<<<<<<<<ADDED HERE
    return (    
        <nav className="Nav">
            <form className="searchForm" onSubmit={(e) => e.preventDefault()}>
                <label htmlFor="search">Search Posts</label>
	        <input
	            id="search"
	            type="text"
	            placeholder="Search Posts"
	            value={search}
	            onChange={(e) => setSearch(e.target.value)}
            </form> 
            <ul>
                <li><Link to="/">Home</li>
                <li><Link to="/post">Post</li>
                <li><Link to="/about">About</li>
            </ul> 
        </nav>
        </nav>
    )
}

export default Nav

but there is a pattern that emerges from these changes as we 
are no longer destructuring as props but instead 
we insert those props right inside the useContext as we use that hook
then we can eliminate the props here in the function parenthesis  v07.28.16


const Nav = ({ search, setSearch }) => {			// 1st show the code to be changed
    const { width } = useContext(DataContext);	

const Nav = ({ search, setSearch }) => {			// grab search, setSearch
    const { search, setSearch } = useContext(DataContext);

const Nav = () => {
    const { search, setSearch } = useContext(DataContext);


we also see that Home receives searchResults, fetchError and isLoading

  return (
     <div className="App">
       <DataProvider>					
       <Header title="React JS Blog" width={width} />					<<<<<<
       <Nav search={search} setSearch={setsearch} />					<<<<<<
       <Switch>
         <Route exact path="/">
           <Home 			
             posts={searchResults} 							<<<<<<
             fetchError={fetchError}							<<<<<<
             isLoading={isLoading}							<<<<<<
           />			
         </Route>

and now in DataContext.js we need to remember to pass along search and setSearch in the DataContext

        <DataContent.Provider value={{
            width 
        }}>

so adding the additional two terms here

        <DataContent.Provider value={{
            width, search, setSearch,
        }}>


and now we see that Home receives searchResults eventhough
we labeled it as posts
also we need fetchError and isLoading so...

           <Home 			
             posts={searchResults} 							<<<<<<
             fetchError={fetchError}							<<<<<<
             isLoading={isLoading}							<<<<<<
 
...so adding the additional two terms here

        <DataContent.Provider value={{
            width, search, setSearch,
            searchResults, fetchError, isLoading
        }}>

save

now pull up the Home.js component		v 07.29.12


// updated Home.js here
 
import Feed from './Feed';

const Home = ({ posts }) => {
  return (
    <main className="Home">
        {isLoading && <p className="statusMsg">Loading</p>}
        {!isLoading && fetchError && <p className="statusMsg" style={{color: "red"}}>{fetchError}</p>}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={posts} /> : <p className="statusMsg">No posts to display.</p>)}
    </main>
  )
}

export default Home


in Home.js component, from Header.js		
import both useContext, DataContext
pull into const Home const { searchResults, fetchError, isLoading } = useContext(DataContext);

inside Home.js function, need to change posts.length ternary to searchResults.length
			 need to change posts={posts} to posts={searchResults}

in Nav.js component
import both useContext, DataContext

in DataContext.js
return all these values: width, search, setSearch, searchResults, fetchError, isLoading

check application to verify its working, reload, test search.

back in App.js
we have eliminated (ie delete) all 3 props that were being drilled down to Home.js component
	posts={searchResults}	fetchError={fetchError}		isLoading={isLoading}
can specify in Route exact path component={Home}

SUMMARY: BEFORE { receive 5 deconstructed props }, AFTER import from useContext(DataContext)
CHANGE: how we receive the data: BEFORE deconstructed, AFTER import from useContext(DataContext).Provider
DETAILS:
NewPost.js receives 5 different props that are being drilled down	handleSubmit, postTitle, setPostTitle, postBody, setPostBody
in Header.js file, copy 2 import statements useContext, DataContext, paste into NewPost.js
from Header.js copy const width = useContext(DataContext) line and paste into NewPost
then take all 5 props and paste into const { pastehere } = useContent(DataContext)
then in NewPost eliminate 5 deconstructors
Need to switch the Route path into a component path

in EditPost
COPY/PASTE both import statements
BEFORE: drilling down deconstructed 6 props: {posts, handleEdit, editTitle, setEditTitle, editBody, setEditBody}
AFTER: import via useContext(DataContext).Provider
VERIFY: 6 props are being passed thru the JSX DataContext.Provider value={{here}}
Switch Route path into a component path
Reload app and test

in PostPage
COPY/PASTE both import statements
COPY const { search, setSearch } = useContext(DataContext)
PASTE into PostPage arrow function
REPLACE cut out deconstructed terms { posts, handleDelete } and paste into useContext(DataContext)
VERIFY: { posts, handleDelete } are being passed thru the JSX DataContext.Provider
Switch Route path into a component path

Review
App.js file is much slimmer, cleaner
JSX <DataProvider> surrounds everything
Notice we are not passing down any props at all, so these functions can be identified as components
TEST make sure app is working
Remove anything not needed in App.js file thus can delete useHistory, useState, useEffect, format, api, useWindowSize, useAxiosFetch
we are left with import components, destructure Route, Switch from react-router-dom and import DataProvider from DataContext
we can remove all these pieces of useState, useHistory, useWindowSize
we can remove useEffect, setSearchResults, 
we can remove all the different functions handleSubmit, handleEdit, handleDelete
now App.js is much smaller	v07.40.16


Add App.js v07.41.59

FROM

function App() {
  return (
    <div className="App">
      <DataProvider>
        <Header title="React JS Blog" />
        <Nav />
        <Switch>
          <Route exact path="/" component={Home} />
          <Route exact path="/post" component={NewPost} />
          <Route path="/edit/:id" component={EditPost} />
          <Route path="/post/:id" component={PostPage} />
          <Route path="/about" component={About} />
          <Route path="*" component={Missing} />
        </Switch>
        <Footer />
      </DataProvider>
    </div>
  )
}

when parent component renders then children components also render causing many re-renders
but now everything that subscribes to DataContext will re-render when Context gets updated
so is this effective and efficient as possible?
look at App.js and look at each component
ex 1 Header does not need to recieve any of the Post data as Header only 
	1 receives title prop
	2 passing width to Header which determines icon for Header
ex 2 Footer is not receiving any data either so does not need to be there

we could move the <DataProvider> tag and wrap it around everything starting at <Nav>
and ending </DataProvider> after the </Switch> route
b/c that really needs the post data

function App() {
  return (
    <div className="App">
      <DataProvider>					<<<<FROM HERE 
        <Header title="React JS Blog" />		<<<<TO AFTER THIS
        <Nav />
        <Switch>
          <Route exact path="/" component={Home} />
          <Route exact path="/post" component={NewPost} />
          <Route path="/edit/:id" component={EditPost} />
          <Route path="/post/:id" component={PostPage} />
          <Route path="/about" component={About} />
          <Route path="*" component={Missing} />
        </Switch>
        <Footer />
      </DataProvider>
    </div>
  )
}


function App() {
  return (
    <div className="App">
      <DataProvider>					<<<<FROM HERE 
        <Header title="React JS Blog" />		<<<<TO AFTER THIS
        <Nav />
        <Switch>
          <Route exact path="/" component={Home} />
          <Route exact path="/post" component={NewPost} />



function App() {
  return (
    <div className="App">
      <Header title="React JS Blog" />			<<<<
      <DataProvider>					<<<<
        <Nav />
        <Switch>
          <Route exact path="/" component={Home} />
          <Route exact path="/post" component={NewPost} />



          <Route path="*" component={Missing} />
        </Switch>
        <Footer />					<<<FROM HERE
      </DataProvider>					<<<FROM after Footer
    </div>


          <Route path="*" component={Missing} />
        </Switch>
      </DataProvider>					<<<
      <Footer />					<<<to now before Footer
    </div>


so now we have this

function App() {
  return (
    <div className="App">
      <Header title="React JS Blog" />			<<<<TO AFTER THIS
      <DataProvider>					<<<<FROM HERE 
        <Nav />
        <Switch>
          <Route exact path="/" component={Home} />
          <Route exact path="/post" component={NewPost} />
          <Route path="/edit/:id" component={EditPost} />
          <Route path="/post/:id" component={PostPage} />
          <Route path="/about" component={About} />
          <Route path="*" component={Missing} />
        </Switch>
      </DataProvider>
      <Footer />
    </div>
  )
}


Now that we have changed that, we still need to change the Header just a little
b/c right now the Header does depend on the data from DataProvider

so lets look at Header.js
and we can remove import useContext and import DataContext
but then we need to think about how to get the width

BEFORE 

import { FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';
import { useContext } from 'react';					<<<REMOVE THIS IMPORT
import DataContext from './context/DataContext';			<<<REMOVE THIS IMPORT

const Header = ({ title }) => {
    const { width } = useContext(DataContext);

    return (
        <header className="Header">
            <h1>{title}</h1>
            {width < 768 ? <FaMobileAlt />
                : width < 992 ? < FaTabletAlt />
                    : < FaLaptop />}
        </header>
    )
}

export default Header



but then we need to think about how to get the width
but notice that it never had to be passed down to begin with (ATUL *freeway overpass)
so what we could is just import useWindowSize hook
like this
import useWindowSize from '../hooks/useWindowSize';

and now that we have the useWindowSize hook
STOP: defining it using DataContext	const { width } = useContext(DataContext);
NOW YES: define it from useWindowSize		const { width } = useWindowSize();			v07.42.11

Note: this is a very simple change but it 
de-coupled the Header from all the data that was involved with the Post
Now go back to DataContext 
1) remove import useWindowSize from hooks/useWindowSize
2) dont need to define width inside DataProvider using const { width } = useWindowSize();
3) dont need to pass width down at all as it can be contained within the Header component itself
   thus the Header component can just use that hook

AFTER

import { FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';
import useWindowSize from '../hooks/useWindowSize';				<<<<<<<<<<ADDED HERE

const Header = ({ title }) => {
    const { width } = useWindowSize();						<<<<<<<<<<CHANGED HERE see 2) 

    return (
        <header className="Header">
            <h1>{title}</h1>
            {width < 768 ? <FaMobileAlt />
                : width < 992 ? < FaTabletAlt />
                    : < FaLaptop />}
        </header>
    )
}

export default Header


v07.42.20
then we go back to the DataContext.js

BEFORE DataContext.js

import { createContext, useState, useEffect } from 'react';
import { useHistory } from 'react-router'dom';
import { format } from 'date-fns';				
import api from '../api/posts';					
import useWindowSize from '../hooks/useWindowSize';		<<<DONT NEED THIS ANYMORE
import useAxiosFetch from '../hooks/useAxiosFetch';		

const DataContext = createContext({});

export const DataProvider = ({ children }) => {
    const [posts, setPosts] = useState([])
    const [search, setSearch] = useState('');
    const [searchResults, setSearchResults] = useState([]);
    const [postTitle, setPostTitle] = useState('');
    const [postBody, setPostBody] = useState('');
    const [editTitle, setEditTitle] = useState('');
    const [editBody, setEditBody] = useState('');
    const history = useHistory();
    const { width } = useWindowSize();				<<<DONT need to define v07.42.30

    const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');
 


from DataContext.js

    return (
        <DataContext.Provider value={{
            width, search, setSearch,					<<<<<<<<<<<<<HERE delete width
            searchResults, fetchError, isLoading,
            handleSubmit, postTitle, setPostTitle, postBody, setPostBody,
            posts, handleEdit, editBody, setEditBody, editTitle, setEditTitle,
            handleDelete
        }}>
            {children}
        </DataContext.Provider>
    )
}




            width, search, setSearch,					<<<<<<<<<<<<<HERE delete width
            search, setSearch,						<<<<<<<<<<<<<HERE deleted


Now, if we stop and think about our other components, 
some info that we previously had in a parent, now, does not
need to be passed down either.
Examples:
handleDelete is probably going to be only on the PostPage where the delete button is located
handleEdit is probably going to be only on the page where the Edit button is located
handleSubmit is probably only on the NewPost page	v07.43.07

part of NewPost.js is here

import { useContext } from 'react';
import DataContext from './context/DataContext';

const NewPost = ({
    const { handleSubmit, postTitle, setPostTitle, postBody, setPostBody } = useContext(DataContext);	<<<LOOK HERE
    return (
        <main className="NewPost">



so lets look at the NewPost.js page		v 07.43.13

const NewPost = () => {

    const { handleSubmit, postTitle, setPostTitle, postBody, setPostBody } = useContext(DataContext);   <<<LOOK HERE
			  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			  this is only for the this form. It has no other role in the application

So we could keep this in state with this component WITHOUT sending it to a Context
b/c it does not need to be shared with other components.
Context is about sharing with other components (ie sub/pub).

so at the top of NewPost.js we could import useState

import ( useContext } from 'react';
import ( useState, useContext } from 'react';

Now we go back to DataContext.js
for these elements		const postTitle, setPostTitle, postBody, setPostBody
we CUT out those lines from DataContext.js 
and paste into NewPost.js


BEFORE	DataContext.js

export const DataProvider = ({ children }) => {
    const [posts, setPosts] = useState([])
    const [search, setSearch] = useState('');
    const [searchResults, setSearchResults] = useState([]);
    const [postTitle, setPostTitle] = useState('');		<<<<CUT OUT
    const [postBody, setPostBody] = useState('');		<<<<CUT OUT
    const [editTitle, setEditTitle] = useState('');
    const [editBody, setEditBody] = useState('');
    const history = useHistory();

    const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

AFTER	DataContext.js

export const DataProvider = ({ children }) => {
    const [posts, setPosts] = useState([])
    const [search, setSearch] = useState('');
    const [searchResults, setSearchResults] = useState([]);
    const [editTitle, setEditTitle] = useState('');
    const [editBody, setEditBody] = useState('');
    const history = useHistory();

    const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');


BEFORE NewPost.js

import { useContext } from 'react';
import DataContext from './context/DataContext';

const NewPost = ({
    const { handleSubmit, postTitle, setPostTitle, postBody, setPostBody } = useContext(DataContext);	<<<LOOK HERE
    return (
        <main className="NewPost">


AFTER NewPost.js

import { useContext } from 'react';
import DataContext from './context/DataContext';

const NewPost = ({
    const [postTitle, setPostTitle] = useState('');		<<<<PASTE HERE
    const [postBody, setPostBody] = useState('');		<<<<PASTE HERE
    const { handleSubmit, postTitle, setPostTitle, postBody, setPostBody } = useContext(DataContext);	<<<LOOK HERE
    return (
        <main className="NewPost">


now notice the duplication here

           postTitle, setPostTitle
           postBody, setPostBody
    const { handleSubmit, postTitle, setPostTitle, postBody, setPostBody } = useContext(DataContext);
			  ^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^  ^^^^^^^^^^^

thus can eliminate here  v07.44.08
    const { handleSubmit, postTitle, setPostTitle, postBody, setPostBody } = useContext(DataContext);
    const { handleSubmit } = useContext(DataContext);


And now the same can be done with handleSubmit as this is the only place that function is called
1 inside NewPost.js is the only place that function is called
2 we might need some other state that is used inside of handleSubmit
3 but we could easily import that other state from the Context
4 so we go back to DataContext.js and grab (cut out) handleSubmit function
5 paste handleSubmit into the NewPost.js component
6 delete the handleSubmit from destructured useContext hook
7 but keep useContext hook line b/c handleSubmit probably has something else we need related to Post

const NewPost = ({
    const [postTitle, setPostTitle] = useState('');
    const [postBody, setPostBody] = useState('');
    const { handleSubmit } = useContext(DataContext);		<<<<<<<is the only place that function is called
    return (
        <main className="NewPost">


so lets look more closely at handleSubmit			v07.44.55
clearly it uses posts	
    const { handleSubmit } = useContext(DataContext);
from #6 delete handleSubmit
    const { } = useContext(DataContext);
add posts given that handleSubmit uses posts
    const { posts } = useContext(DataContext);
it also uses setPosts so add that as well
    const { posts, setPosts } = useContext(DataContext);
it also uses setPostBody and setPostTitle are already contained within
    const [postTitle, setPostTitle] = useState('');
    const [postBody, setPostBody] = useState('');

const NewPost = ({
    const [postTitle, setPostTitle] = useState('');
    const [postBody, setPostBody] = useState('');
    const { posts, setPosts } = useContext(DataContext);
    const history = useHistory();


    const handleSubmit = async (e) => {
        e.preventDefault();
        const id = posts.length ? posts[posts.length - 1].id + 1 : 1;		<<<<<USES posts
        const datetime = format(new Date(), 'MMMM dd, yyyy pp');
        const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
        const response = await api.post('/posts', newPost);
        const allPosts = [...posts, response.data];
        setPosts(allPosts);							<<<<<<USES setPosts
        setPostTitle('');
        setPostBody('');
        history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }


we need to import useHistory from react-router-dom
then we need to define our history to be able to use it

BEFORE
import ( useState, useContext } from 'react';
import DataContext from './context/DataContext';

AFTER
import ( useState, useContext } from 'react';
import DataContext from './context/DataContext';
import { useHistory } from 'react-router-dom';


it also has an api call inside here
thus we need to import this into the function as well

import ( useState, useContext } from 'react';
import useHistory from 'react-router-dom';
import api from './api/posts';
import DataContext from './context/DataContext';

so now we have our handleSubmit function in NewPost.js
and we are containing the state within the component that really does not need to be shared
and we are pulling in the state that does need to be shared between components
and here that is posts
    const { posts, setPosts } = useContext(DataContext);
	    ^^^^^

and we are pulling in the state that does need to be shared

NewPost.js

import ( useState, useContext } from 'react';
import useHistory from 'react-router-dom';
import api from './api/posts';
import DataContext from './context/DataContext';

const NewPost = ({
    const [postTitle, setPostTitle] = useState('');
    const [postBody, setPostBody] = useState('');
    const { posts, setPosts } = useContext(DataContext);	// and we are pulling in the state that does need to be shared
    const history = useHistory();

    const handleSubmit = async (e) => {
        e.preventDefault();
        const id = posts.length ? posts[posts.length - 1].id + 1 : 1;
        const datetime = format(new Date(), 'MMMM dd, yyyy pp');
        const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
        const response = await api.post('/posts', newPost);
        const allPosts = [...posts, response.data];
        setPosts(allPosts);
        setPostTitle('');
        setPostBody('');
        history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }


now lets save this and go back to our DataContext.js
we have already removed the function
and we have already removed the state
but now lets go down to the return block for DataContext.Provider
and we need to remove it b/c it no longer needs to be passed thru the DataContext.Provider

BEFORE
        <DataContext.Provider value={{
            width, search, setSearch,					
            searchResults, fetchError, isLoading,
            handleSubmit, postTitle, setPostTitle, postBody, setPostBody,	<<<<<<<<<<<<<delete here


and we need to remove it b/c it no longer needs to be passed thru the DataContext.Provider

AFTER
        <DataContext.Provider value={{
            width, search, setSearch,					
            searchResults, fetchError, isLoading,


reload app
error due to extra dot in the Header.js import useWindowSize file		v07.47.12
import useWindowSize from '../hooks/useWindowSize';
import useWindowSize from './hooks/useWindowSize';

App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import EditPost from './EditPost';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');
  const [editBody, setEditBody] = useState('');
  const history = useHistory();


2 terminal windows running
- json server running in terminal 1
- react app running in termainal 2

we will apply a couple of custom hooks

rules for react
1 only call Hooks at the top level, 
  dont call Hooks inside loops, conditions, or nested functions
  Why? by following this rule, you ensure Hooks are
  called in the same order each time a component renders
  Thus Hooks can correctly preserve the state of Hooks between multiple 
  useState and useEffect calls.
  reactjs.org/docs/hooks-rules.html

2 call Hooks from React function components
  Why? by following this rule you ensure all stateful logic in a component
  is clearly visible from its source code.

3 can call Hooks from custom Hooks


Collection of React Hooks
nikgraf.github.io/react-hooks
more than one hook that accomplishes the same thing b/c it has a different author

npm
react-use

Now back to our own project

Here in VSCode, we have App.js file open
Select src folder
create new folder inside it called hooks
create new file inside hooks folder 		v06.43.38
  new file is called useWindowSize.js
import useState and useEffect b/c we can use these inside our custom hook
every React hook starts with use__________
const useWindowSize
set this equal to an arrow function  v06.44.20
and setWindowSize
these both use state so we need to set the state
so = useState()
and now inside useState we use an { object }
set this to width: undefined 
b/c thats truely what it is at this point
its an undefined value

same for the height

import {}
import { useState, useEffect }
import { useState, useEffect } from "react";  

const useWindowSize = () => {

}

const useWindowSize = () => {
    const [windowSize, setWindowSize]
}

const useWindowSize = () => {
    const [windowSize, setWindowSize] = useState()
}

const useWindowSize = () => {
    const [windowSize, setWindowSize] = useState({  })
}

const useWindowSize = () => {
    const [windowSize, setWindowSize] = useState({ 
        width: undefined,
        height: undefined
    });
}

now our initial state is set
next we add useEffect here
with an arrow function		v06.45.14

const useWindowSize = () => {
    const [windowSize, setWindowSize] = useState({ 
        width: undefined,
        height: undefined
    });

    useEffect()				<<<<<<<<ADD HERE
}

    useEffect()
    useEffect(()=> {})

v06.45.14

    useEffect(()=> {
        
    })

now focus on useEffect dependencies
we want this to run at load time and that is the only time this will run	, [])
now we define a function inside of useEffect called handleResize	const handleResize
this function handles if the window is resized
add an arrow function inside						= () => {}

    useEffect(()=> {
        
    }, [])

    useEffect(()=> {

        const handleResize = () => {}

    }, [])


now we setWindowSize () 
and set state inside of this function	{}

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({})
        }

    }, [])


so then we start defining the setWindowSize function
with the width					width: 
here we add window.innerWidth	     		width: window.innerWidth
then we add the height				height: 
her we add window.innerHeight			height: window.innerHeight
both of these will track the value of the window size
if this function is called into action
(ie it grabs the innerWidth and innerHeight, then
    that gets inserted into width and height, then
    that gets used by setWindowSize in the handleResize function)	v06.46.11

add ;

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({})
                width:
        }

    }, [])

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({})
                width: window.innerWidth
        }

    }, [])

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({})
                width: window.innerWidth
                height: window.innerHeight
        }

    }, []);


v06.46.11
ok - now we have created the handleResize function
now we need to call it
so we have handleResize() called into action

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({})
                width: window.innerWidth
                height: window.innerHeight
        }

        handleResize();

    }, []);


so note, at load time we have initial values for the width and height
this only happens once at load time b/c we included them as dependencies    []);

but how to get those values to adjust when the window is resized?
use an event listeners (just like in regular javascript)

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({})
                width: window.innerWidth
                height: window.innerHeight
        }

        handleResize();

        window.addEventListener() 		<<<<<<<<<<<<<<<<<ADD HERE

    }, []);


so lets add an event listener to the window		window.addEventListener()
we listen for the resize event				("resize")

we call this function into action by calling it		, handleResize


        window.addEventListener()
        window.addEventListener("resize")
        window.addEventListener("resize", handleResize);

so for useEffect now we have 

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({})
                width: window.innerWidth
                height: window.innerHeight
        }

        handleResize();

        window.addEventListener("resize", handleResize);

    }, []);


and for useWindowSize BEFORE and AFTER code added for useEffect
this is what we need to get those values everytime
b/c 
1 we added this listener at the beginning so it was used only once
2 but there is someelse we need to do: need to prevent a memory leak in the app
  how? remove the event listener
  useEffect has a cleanup function that will only run when the dependencies change for useEffect
  and so we know the dependencies will NOT change here b/c this is only at load time
  but it also happen when the application closes out.
  Thus runs the cleanup function and removes that event listener	const cleanUp
 
  Set cleanUp equal to an arrow function
        const cleanUp
        const cleanUp = () => {}


const useWindowSize = () => {
    const [windowSize, setWindowSize] = useState({ 
        width: undefined,
        height: undefined
    });

    useEffect()				<<<<<<<<ADD HERE
}


const useWindowSize = () => {
    const [windowSize, setWindowSize] = useState({ 
        width: undefined,
        height: undefined
    });

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({})
                width: window.innerWidth
                height: window.innerHeight
        }

        handleResize();

        window.addEventListener("resize", handleResize);

        const cleanUp = () => {}
  
    }, []);
}


so combining useWindowSize, useEffect, handleResize, event listener, and now cleanUp
we have overall
lets add a console.log statement	console.log('runs if a useEffect dependency changes')
so we will see this in the logs when this runs		v06.48.18
then we call window.removeEventListener
with text "resize" and remove the handleResize function from that event

            window.removeEventListener
            window.removeEventListener()
            window.removeEventListener("resize")
            window.removeEventListener("resize", handleResize)


        const cleanUp = () => {
            console.log('runs if a useEffect dependency changes')
            // add removeEventListener
        }


        const cleanUp = () => {
            console.log('runs if a useEffect dependency changes')
            window.removeEventListener("resize", handleResize)
        }

 
note that we have not yet called cleanUp into action yet
all we have done so far is defined cleanUp
all you need to do to use cleanUp is add a return at the end
so its

        return cleanUp;

and then now its called into action

then we to return the windowSize value

    return windowSize;

then at the end of useWindowSize function is

export default useWindowSize;



so far overall we have


import { useState, useEffect } from "react";  

const useWindowSize = () => {
    const [windowSize, setWindowSize] = useState({ 
        width: undefined,
        height: undefined
    });

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({
                width: window.innerWidth
                height: window.innerHeight
            });
        }

        handleResize();

        window.addEventListener("resize", handleResize);

        const cleanUp = () => {
            console.log('runs if a useEffect dependency changes')
            window.removeEventListener("resize", handleResize);
        }

        return cleanUp;

    }, []);

    return windowSize;

}

export default useWindowSize;

so summary of this is				v06.49.21

start out with useState and useEffect		import { useState, useEffect } from "react";  

define the hook					const useWindowSize = () => {

set the state					const [windowSize, setWindowSize] = useState({ 

we useEffect					useEffect(()=> {

key part is to call it once at load time using 	
						const handleResize();
but we also add an event listener so anytime the resize event fires 
						window.addEventListener("resize", handleResize);

we can continue to call handleResize function
						handleResize);

then we call cleanUp function which is import to prevent a memory leak
						const cleanUp = () => {
						return cleanUp;

so now we completed the entire custom hook and now lets use it in our application

lets go back to the App.js file
where we have our imports
underneath the import api statement
we add the import useWindowSize
from .hooks / useWindowSize

App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import EditPost from './EditPost';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';
import useWindowSize from './hooks/useWindowSize';		<<<<<<<<<<<<

save
so now we have saved it but not yet using it
we only need to pull the width out so we destructure it
and pull out width only			  		const { width } = useWindowSize();



function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');
  const [editBody, setEditBody] = useState('');
  const history = useHistory();
  const { width } = useWindowSize();
 
so now we have
1 defined the function
2 import the fuuntion
3 now lets use it (ie width)
lets pass it into the JSX Header

       <Header title="React JS Blog"/>
       <Header title="React JS Blog" width={wdith} />

this completes the changes to the App.js file

now lets add it to the Header.js file			v06.51.11

open Header.js

const Header = ({ title }) => {
    return (
        <header className="Header">
            <h1>{title}</h1>
        </header>
    )
}

export default Header

add width to the destructured props at the top of the header file

const Header = ({ title }) => {
const Header = ({ title, width }) => {

now we also need to do an import
we need FaLaptop
and also FaTabletAlt
and finally FaMobileAlt

import {FaLaptop } 
import {FaLaptop, FaTabletAlt } 
import {FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';


so now Header.js file looks like this

import {FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';

const Header = ({ title, width }) => {
    return (
        <header className="Header">
            <h1>{title}</h1>
        </header>
    )
}

export default Header


we need to make sure we imported react-icons/fa in package.json dependencies
and checking that, we find that we do not have react-icons/fa installed
so we need to install this
so open new Terminal window
$npm i react-icons		// this installs react-icons

now its installed and we can see in package.json dependencies
now we need to restart the react application as well
now close terminal window and focus on VSCode

back to Header.js file
now we want to use those Fa icons in the header based on the width data
width is now destructured 		const Header = ({ title, width })
so we can use width inside the header component
and we base this calculation upon the value of the width
using a ternary statement
if width is less than 768 then we use the FaMobileAlt icon
then if width is less than 992 (so its greater then 768 but less than 992)
then start another ternary statement
    if this is true then <FaTabletAlt /> icon
        finally if this is also false then we show <FaLaptop Value /> icon


            <h1>{title}</h1>
            // add width here

            <h1>{title}</h1>
            {width}

            <h1>{title}</h1>
            {width < 768 ? <FaMobileAlt />
                : width < 992 ? < FaTabletAlt />
                    : < FaLaptop />}


so now Header.js file looks like this

import {FaLaptop, FaTabletAlt, FaMobileAlt } from 'react-icons/fa';

const Header = ({ title, width }) => {
    return (
        <header className="Header">
            <h1>{title}</h1>
            {width < 768 ? <FaMobileAlt />
                : width < 992 ? < FaTabletAlt />
                    : < FaLaptop />}
        </header>
    )
}

export default Header


save these changes
and look at the application rendered in Chrome
default view shows laptop icon in top right
lets use DevTools to change screen sizing
start to shrink screen size down and now we see tablet icon
make it larger again to show laptop
change itunes view to show iphone 6/7/8+ and this shows iphsfaone icon
so our custom hook is working as expected		v 06.55.41

now we go to the useWindow hook that we created  	v 06.56.10

lets demonstrate the cleanUp function where the 
cleanUp function will log to the window

        const cleanUp = () => {
            console.log('runs if a useEffect dependency changes')
            window.removeEventListener("resize", handleResize);
        }

        return cleanUp;

note there are no dependencies here 
so the cleanUp just needs to reload
reload can happen if there is any change to the code -- add a space

            console.log('runs if a useEffect dependency changes')
            console.log(' runs if a useEffect dependency changes')

so add the space
save
reload now automatically occurs b/c there are no other dependencies and so
the only change the code is the additional single text space added

Terminal Console window shows this message

  runs if a useEffect dep changes

so this Terminal Console output shows that the cleanUp function does indeed run

now lets
refactor the cleanUp function
delete the console.log line
just return an anonymous function		        return () => 

note we 
	1 define cleanUp then 
	2 we define console log
	3 we define how cleanUp will run

refactor 	is to delete line 2
		then since 1 and 3 are essentially the same, delete 1 and left with 3 only	

move removeEventListener line and place into anonymous function


       const cleanUp = () => {
            console.log('runs if a useEffect dependency changes')
            window.removeEventListener("resize", handleResize);
       }

       return cleanUp;

       const cleanUp = () => {
            window.removeEventListener("resize", handleResize);
       }

       return cleanUp;

       const cleanUp = () => {
            window.removeEventListener("resize", handleResize);
       }

       return () => 


       const cleanUp = () => {
            window.removeEventListener("resize", handleResize);
       }

       return () => window.removeEventListener("resize", handleResize);

so then this

       const cleanUp = () => {
       }

       return () => window.removeEventListener("resize", handleResize);

refactors or reduces to 

       return () => window.removeEventListener("resize", handleResize);

so we can see that they accomplish the same thing
so note that the refactored cleanUp is only 1 line of code and sits inside the useEffect function


so now we are left with useWindowSize.js

import { useState, useEffect } from "react";  

const useWindowSize = () => {
    const [windowSize, setWindowSize] = useState({ 
        width: undefined,
        height: undefined
    });

    useEffect(()=> {

        const handleResize = () => {
            setWindowSize({
                width: window.innerWidth
                height: window.innerHeight
            });
        }

        handleResize();

        window.addEventListener("resize", handleResize);

       return () => window.removeEventListener("resize", handleResize);

    }, []);

    return windowSize;

}

export default useWindowSize;


Ok - so now we have finished the useWindowSize custom hook
there are other recipes for useWindowSize other there by other authors

Next we tackle a more complex custom hook 	v06.57.58
the more complex hook is a useFetch hook
but we add a twist given that we have already add Axios to our project
so we will create a useAxiosFetch hook

open file tree
new file inside hooks folder		useAxiosFetch.js
hide file tree

import useState and useEffect from react			import { useState, useEffect } from 'react';
also import Axios from Axios					import axios from 'axios';
next we define const useAxiosFetch using an arrow function	= () => {}
it accepts a data url						(dataUrl)
now inside the arrow function we add several pieces of state here
now here instead of saying posts, we want this to be generic 
so we could use it an another application
so a custom hook is much like a utility function		const []
so inside the custom hook we have data and setData		data, setData
set this equal to useState and put in an empty array


import { useState, useEffect } from 'react'; 
import axios from 'axios';

const useAxiosFetch = 
const useAxiosFetch = () => {}

const useAxiosFetch = (dataUrl) => {}

const useAxiosFetch = (dataUrl) => {
    const []

}

const useAxiosFetch = (dataUrl) => {
    const [data, setData]

}

const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);

}


then we also need an empty array to hold fetchError		const [fetchError, ]
and a setFetchError					    	const [fetchError, setFetchError]
and set them equal to useState (null)				= useState(null)
then we also need an emtpy array to hold the loading State
where we hold isLoading and setIsLoading			const [isLoading, setIsLoading]
and this is also equal to null					= useState(null);
	
const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);
    const [fetchError, setFetchError] = useState(null);
    const []

}

const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);
    const [fetchError, setFetchError] = useState(null);
    const [isLoading, setIsLoading] = useState(null);

}


now lets create our useEffect function

const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);
    const [fetchError, setFetchError] = useState(null);
    const [isLoading, setIsLoading] = useState(null);

    useEffect()
}


start with useEffect 					useEffect()
and an anonymous function				useEffect(() => {})		v07.00.01
Define let isMounted equals true			let isMounted = true;
we really want the component to be mounted
and not attempt to apply something after it is unmounted
Next we need to define a source				const source = axios
for Axios we set a CancelToken				axios.CancelToken
see Axios documentation for details on this
this allows us to cancel the request if for whatever reason the component is unmounted
so this becomes our source
We define our fetchData function inside of useEffect	const fetchData = 
we call it async and define it as url as we further define this function 	async (url)
Note it can be confusing to name a parameter we are going to use
and then use that same name when you create a definition
			const useAxiosFetch = (dataUrl) =>			dataUrl
			const fetchData = async (url) = >			url
so better to use different names here
b/c the url is just used in the definition of the function 


    useEffect()

    useEffect(() => {})

    useEffect(() => {
        let isMounted = true;
        const source = axios.CancelToken.source();

        const fetchData = async (url) => {}
    })


now inside our fetchData function, 
the first thing we do is setIsLoading to true		setIsLoading(true);
and then we go ahead and add a try {} block		try{}	
and inside the try block 	
we have a const response				const response
and set this equal to await axios.get()			= axios.get()
inside the url parameter we first include the url	(url)
then we need to apply our cancel token			(url, )
and this will allow us to cancel the url request if
we unmount the component				(url, cancelToken: source.token

since this second part is a complex object, it becomes a {}
// see below for continued notes

        const fetchData = async (url) => {}

        const fetchData = async (url) => {
            setIsLoading(true);
	    try{}
        }

        const fetchData = async (url) => {
            setIsLoading(true);
	    try{
                const response = 
            }
        }

        const fetchData = async (url) => {
            setIsLoading(true);
	    try{
                const response = await axios.get(url, )
            }
        }

        const fetchData = async (url) => {
            setIsLoading(true);
	    try{
                const response = await axios.get(url, {})
            }
        }

so we set the cancel token here
and this will allow us to cancel the url request if we unmount the component
so here we set the cancel token						cancelToken: source.token
in the cleanUp we execute or handle it the cancel token
so here is the cancelToken send with the request url			});

        const fetchData = async (url) => {
            setIsLoading(true);
	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
            }
        }

then after we get a response, we need to check to see if the component is mounted
then if the component is yes mounted, we can setData() with response.data	setData(response.data)
then we set the fetchError to null				setFetchError(null)

        const fetchData = async (url) => {
            setIsLoading(true);
	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
                if (isMounted) {
                    setData(response.data);
                    setFetchError(null);
                }
            }
        }


so far we have
new file useAxiosFetch.js		so far we have

import { useState, useEffect } from 'react'; 
import axios from 'axios';

const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);
    const [fetchError, setFetchError] = useState(null);
    const [isLoading, setIsLoading] = useState(null);

    useEffect(() => {
        let isMounted = true;
        const source = axios.CancelToken.source();

        const fetchData = async (url) => {
            setIsLoading(true);
	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
                if (isMounted) {
                    setData(response.data);
                    setFetchError(null);
                }
            }
        }
    })
}


side note here
isLoading useState as a null may not be a good choice
its better to set this to false to begin with			// false 
then we set it to true when the function is called		// true when function is called

    const [isLoading, setIsLoading] = useState(null);
    const [isLoading, setIsLoading] = useState(false);	<<<<<<FALSE HERE

   useEffect(() => {
        let isMounted = true;
        const source = axios.CancelToken.source();

        const fetchData = async (url) => {
            setIsLoading(true);				<<<<<<TRUE HERE

so now we have 

new file useAxiosFetch.js		so far we have

import { useState, useEffect } from 'react'; 
import axios from 'axios';

const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);
    const [fetchError, setFetchError] = useState(null);
    const [isLoading, setIsLoading] = useState(false);		<<<<<<<CHANGED HERE to false

    useEffect(() => {
        let isMounted = true;
        const source = axios.CancelToken.source();

        const fetchData = async (url) => {
            setIsLoading(true);					<<<<<<set to true when called
	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
                if (isMounted) {
                    setData(response.data);
                    setFetchError(null);
                }
            }
        }
    })
}
 
v 07.02.41

ok 
we check to see if isMounted			if (isMounted) 
we set the data 				setData(response.data);

we set the fetch error to null			setFetchError(null);
b/c there was no error otherwise

so now we have finished our try block
so now we need our catch block			catch (err)
and once we catch an error we do this		{}
we need to check if (isMounted)			(isMounted)

and then if the component isMounted 
we setFetchError()
and this will be for the error message		setFetchError(err.message);
and we setData() to an empty array		setData([]);
note we set it to an empty array b/c we received an error
thus we should not use that data anyway
then we add a finally block below

	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
                if (isMounted) {
                    setData(response.data);
                    setFetchError(null);
                }
            } catch (err) {
                if (isMounted)
                    setFetchError(err.message);
                    setData([]);
            }


now lets add a finally block 			finally {}

	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
                if (isMounted) {
                    setData(response.data);
                    setFetchError(null);
                }
            } catch (err) {
                if (isMounted)
                    setFetchError(err.message);
                    setData([]);
            } finally {
            }


and here want to check if the component is mounted && use a timeout here
we use a timeout just to see the loading message for learning and development sake
dont leave the timeout in your final production project
we just do this to display the isLoading message in the console
so setTimeout() and use an arrow function
we setIsLoading to false but only after 2 seconds (ie 2000)
so this 2 seconds will allow us time to see the IsLoading message and
verify that it is in fact working

            } finally {
                isMounted && setTimeout()
            }

            } finally {
                isMounted && setTimeout(() => )
            }

            } finally {
                isMounted && setTimeout(() => setIsLoading(false), 2000);
            }

so far now we have

import { useState, useEffect } from 'react'; 
import axios from 'axios';

const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);
    const [fetchError, setFetchError] = useState(null);
    const [isLoading, setIsLoading] = useState(false);		<<<<<<<CHANGED HERE to false

    useEffect(() => {
        let isMounted = true;
        const source = axios.CancelToken.source();

        const fetchData = async (url) => {
            setIsLoading(true);					<<<<<<set to true when called
	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
                if (isMounted) {
                    setData(response.data);
                    setFetchError(null);
                }
            } catch (err) {
                if (isMounted)
                    setFetchError(err.message);
                    setData([]);
            } finally {
                isMounted && setTimeout(() => setIsLoading(false), 2000);
            }
        }
    })
}

then we want to call fetchData()
and remember that the hook receives a data url 
as the actual parameter

	fetchData(dataUrl);

so the dataUrl is what we actually pass in

note in the definition we used url 			const fetchData = async (url) => {
but above it actually receives the dataUrl		const useAxiosFetch = (dataUrl) => {

so this dataUrl is what we call fetchData with		fetchData(dataUrl);

        fetchData(dataUrl);				<<<<<<<<<<<<<HERE


and after we call fetchData, then we define a cleanUp		v07.04.31
cleanUp arrow function							const cleanUp = () => {}
we add console.log('clean up function') so we know its running		console.log('clean up function')
then after this we set the isMounted to false		isMounted = false;
and we cancel the request				source.cancel();

Notice if the request is already then this is ok (ie no harm no foul)
but this will only run whenever the dependecy changes for the useEffect

then we return the cleanUp function			return cleanUp;


        fetchData(dataUrl);

	const cleanUp = () => {}

	const cleanUp = () => {
            console.log('clean up function')
            isMounted = false;
            source.cancel();
        }

        return cleanUp;

thus so far we have

import { useState, useEffect } from 'react'; 
import axios from 'axios';

const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);
    const [fetchError, setFetchError] = useState(null);
    const [isLoading, setIsLoading] = useState(false);	

    useEffect(() => {
        let isMounted = true;
        const source = axios.CancelToken.source();

        const fetchData = async (url) => {
            setIsLoading(true);			
	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
                if (isMounted) {
                    setData(response.data);
                    setFetchError(null);
                }
            } catch (err) {
                if (isMounted)
                    setFetchError(err.message);
                    setData([]);
            } finally {
                isMounted && setTimeout(() => setIsLoading(false), 2000);
            }
        }

        fetchData(dataUrl);				<<<<<<<<<<<<<HERE

	const cleanUp = () => {				<<<<<<<<<<<<<HERE
            console.log('clean up function')
            isMounted = false;
            source.cancel();
        }

        return cleanUp;					<<<<<<<<<<<<<HERE
    })
}


after we return the cleanUp function, we want to set the dependencies for useEffect
and so the dependency here will be the dataUrl that is passed into useAxiosFetch via 
the code  		const useAxiosFetch = (dataUrl) => {
and notice that if the dataUrl changes then we want to run it again thus its a dependency

    })

    }, [dataUrl]);

now with that complete, we can return three things from our custom hook
return 
1 the data that we have in state
2 the fetchError and
3 isLoading

    return {} 
    return { data, } 
    return { data, fetchError, } 
    return { data, fetchError, isLoading }; 

so we need all three of these things returned from our custom hook 

       return cleanUp;
    }, [dataUrl]);

    return { data, fetchError, isLoading }; 

}

and now that the hook is complete, we need to export default useAxiosFetch;

       return cleanUp;
    }, [dataUrl]);

    return { data, fetchError, isLoading }; 

}

export default useAxiosFetch;


thus so far we have

import { useState, useEffect } from 'react'; 
import axios from 'axios';

const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);
    const [fetchError, setFetchError] = useState(null);
    const [isLoading, setIsLoading] = useState(false);	

    useEffect(() => {
        let isMounted = true;
        const source = axios.CancelToken.source();

        const fetchData = async (url) => {
            setIsLoading(true);			
	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
                if (isMounted) {
                    setData(response.data);
                    setFetchError(null);
                }
            } catch (err) {
                if (isMounted)
                    setFetchError(err.message);
                    setData([]);
            } finally {
                isMounted && setTimeout(() => setIsLoading(false), 2000);
            }
        }

        fetchData(dataUrl);

	const cleanUp = () => {	
            console.log('clean up function')
            isMounted = false;
            source.cancel();
        }

       return cleanUp;
    }, [dataUrl]);

    return { data, fetchError, isLoading }; 

}

export default useAxiosFetch;


save			v 07.06.08

review of what happening here
defined custom hook 				const useAxiosFetch = (dataUrl) => {

import axios and useState useEffect		import { useState, useEffect } from 'react';
						import axios from 'axios';

we set different states here at the beginning   const [data, setData] = useState([]);
						const [fetchError, setFetchError] = useState(null);
						const [isLoading, setIsLoading] = useState(false);	

we are recieving a data url			const useAxiosFetch = (dataUrl) => {

then we defined our useEffect hook		useEffect(() => {
we set an isMounted status to true		let isMounted = true;
we also defined a cancelation token		const source = axios.CancelToken.source();
then we defined the fetch data function		const fetchData = async (url) => {
and inside this function we have 		try block, catch block, finally block
we are constantly checking to see if the component is mounted		if (isMounted)
and if it is mounted then we take action	setData(response.data); 
(set data state and error to null)		setFetchError(null);
if catch an error (set the error message)	setFetchError(err.message);
and set the data to an empty array		setData([]);
and finally happens no matter what		finally {
check if component is still mounted and if so
set loading to false 				isMounted && setTimeout(() => setIsLoading(false), 2000);
with a delay to test the isLoading message
we call that into action with the url received by the hook		fetchData(dataUrl);
eventually we define and call the cleanup function		const cleanUp = () => {}        return cleanUp;
the cleanup function will cancel a request if the component is unmounted during the request	source.cancel();
and will also set isMounted to false		isMounted = false;
we return the data, possible error and isLoading status		return { data, fetchError, isLoading }; 

and so this is our useAxiosFetch custom hook

now lets put it into action

show file free CONTROL B
go to App.js where we will apply our custom hook
add an import statement

import useAxiosFetch from './hooks/useAxiosFetch';

so we have 
App.js

import Header from './Header';
import Nav from './Nav';
import Footer from './Footer';
import Home from './Home'; 
import NewPost from './NewPost';
import PostPage from './PostPage';
import EditPost from './EditPost';
import About from './About';
import Missing from './Missing';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';
import api from './api/posts';
import useWindowSize from './hooks/useWindowSize';		
import useAxiosFetch from './hooks/useAxiosFetch';		<<<<<<<<<<<<


now after our import, we need to come down to where we define width and windowSize
and under this we set
const equal to
we can destructure what we are receiving from Axios Fetch
we receive the data
the fetchError
and isLoading
and we all this equal to useAxiosFetch()
and now we need to pass in the full url
since we set up the AxiosFetch custom hook to be reusable, we did not specify the baseurl
so what we need to do is put in the full url for our server (and this is the json server url)
the full url is 		http://localhost:3500/posts
we pass this full url to the useAxiosFetch custom hook

  const 
  const {} 
  const { data, } 
  const { data, fetchError, } 
  const { data, fetchError, isLoading } 
  const { data, fetchError, isLoading } = 
  const { data, fetchError, isLoading } = useAxiosFetch()
  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

but notice we also need to remove the current useEffect that we getting our data with
b/c keeping it would be redundant 				v07.09.51

so we delete it (or comment it out)

  useEffect(() => {						// delete this entire useEffect block
    const fetchPosts = async () => {
      try { 
        const response = await api.get('/posts');
        setPosts(response.data)
      } catch (err) {
        if 
          // Not in the 200 response range
          console.log(err.response.data);
          console.log(err.response.status);
          console.log(err.response.headers);
      } else {
          console.log(`Error: ${err.message}`)
      }
    }

    fetchPosts();
  }, [])							// delete this entire useEffect block


but now we have data 
but we do not have posts so there is 1 more step after we get our data back
what do we do now? set the state as we are using it in the rest of the application  v07.10.08
(note we could just use data if we were just displaying the data on the page but
 since we are doing more than that with the application we need the additional code)
so set a useEffect here 
with an anonymous arrow function
now once have the useEffect, then inside it we 
setPosts equal to the data						setPosts(data);
so this updates our Posts state
and we only want to do this when the data changes			}, [data])
this now completes everything we need here
so save


  useEffect()
  useEffect(() => {})
  
  useEffect(() => {
    setPosts(data);  
  })


  useEffect(() => {
    setPosts(data);  
  }, [data])



  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');
// add posts code line here



  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

  useEffect(() => {
    setPosts(data);  
  }, [data])


so now we have everything in place for data 
but we are not using fetchError or isLoading

save
reload app
notice that the app reloads 
and we get the posts to load 

so now lets put put fetchError and isLoading to work

before we put fetchError and isLoading to work we have
App.js

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');
  const [editBody, setEditBody] = useState('');
  const history = useHistory();
  const { width } = useWindowSize();

  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

  useEffect(() => {
    setPosts(data);  
  }, [data])

  useEffect(() => {
    const filteredResults = posts.filter(post => 
      ((post.body).toLowerCase()).includes(search.toLowerCase())
      || ((post.title).toLowerCase()).includes(search.toLowerCase()));

    setSearchResults(filterResults.reverse());
  }, [posts, search])							


  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  return (
     <div className="App">
       <Header title="React JS Blog" width={width} />
       <Nav search={search} setSearch={setsearch} />
       <Switch>
         <Route exact path="/">
           <Home posts={searchResults} />
         </Route>
         <Route exact path="/post">
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         </Route>
         <Route path="/edit/:id">
           <EditPost
             posts={posts}		
             handleEdit={handleEdit}	
             editTitle={editTitle}	
             setEditTitle={setEditTitle}	
             editBody={editBody}	
             setEditBody={setEditBody}	
           />	

         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
     </div>
  )
}


from above:
so now lets put put fetchError and isLoading to work
we need to pass fetchError and isLoading to our home page
so in App.js scroll down to JSX

so we see posts with the {searchResults}
so lets break this up into 3 lines

           <Home posts={searchResults} />

           <Home 
             posts={searchResults} 
           />

then we add fetchError={fetchError}
and we add isLoading={isLoading}
now this finishes the changes for the App.js file
next we make changes to the Home.js file below

line by line progression is

         <Route exact path="/">
           <Home posts={searchResults} />
         </Route>

         <Route exact path="/">
           <Home 
             posts={searchResults} 
           />
         </Route>


         <Route exact path="/">
           <Home 
             posts={searchResults} 
             fetchError={fetchError}
             isLoading={isLoading}
           />
         </Route>


so App.js now is 

function App() {
  const [posts, setPosts] = useState([])
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [postTitle, setPostTitle] = useState('');
  const [postBody, setPostBody] = useState('');
  const [editTitle, setEditTitle] = useState('');
  const [editBody, setEditBody] = useState('');
  const history = useHistory();
  const { width } = useWindowSize();

  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

  useEffect(() => {
    setPosts(data);  
  }, [data])

  useEffect(() => {
    const filteredResults = posts.filter(post => 
      ((post.body).toLowerCase()).includes(search.toLowerCase())
      || ((post.title).toLowerCase()).includes(search.toLowerCase()));

    setSearchResults(filterResults.reverse());
  }, [posts, search])							


  const handleSubmit = (e) => {
    e.preventDefault();
    const id = post.length ? posts[posts.length - 1].id + 1 : 1;
    const datetime = format(new Date(), 'MMMM dd, yyyy pp');
    const newPost = { id, title: postTitle, datetime, body: postBody };
    try {
      const response = await api.post('/posts', newPost);
      const allPosts = [...posts, response.data];
      setPosts(allPosts);
      setPostTitle('');
      setPostBody('');
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  const handleDelete = async (id) => {
    try {
      await api.delete(`/posts/${id}`)
      const postsList = posts.filter(post => post.id !== id);
      setPosts(postsList);
      history.push('/');
    } catch (err) {
        console.log(`Error: ${err.message}`);
    }
  }

  return (
     <div className="App">
       <Header title="React JS Blog" width={width} />
       <Nav search={search} setSearch={setsearch} />
       <Switch>
         <Route exact path="/">
           <Home 				<<<<<<<<<<<<HERE
             posts={searchResults} 		<<<<<<<<<<<<HERE
             fetchError={fetchError}		<<<<<<<<<<<<HERE
             isLoading={isLoading}		<<<<<<<<<<<<HERE
           />					<<<<<<<<<<<<HERE
         </Route>
         <Route exact path="/post">
           <NewPost 
             handleSubmit={handleSubmit}
             postTitle={postTitle}
             setPostTitle={setPostTitle}
             postBody={postBody}
             setPostBody={setPostBody}
           />
         </Route>
         <Route path="/edit/:id">
           <EditPost
             posts={posts}		
             handleEdit={handleEdit}	
             editTitle={editTitle}	
             setEditTitle={setEditTitle}	
             editBody={editBody}	
             setEditBody={setEditBody}	
           />	

         <Route path="/post/:id">
           <PostPage posts={posts} handleDelete={handleDelete} />
         </Route>
         <Route path="/about" component={About} />
         <Route path="*" component={Missing} />

       </Switch>
       <Footer />
     </div>
  )
}

so we have Home.js
we need to destructure what we are passing in			destructured passin
so we pass fetchError into this function 			need to pass in fetchError
using a destructured format					const Home = ({ posts, fetchError })
also pass in using destructured format 				const Home = ({ posts, fetchError, isLoading })
note we want to remove all the <main> elements and start over in this file


const Home = ({ posts }) => {
const Home = ({ posts, fetchError }) => {
const Home = ({ posts, fetchError, isLoading }) => {


import Feed from './Feed';

const Home = ({ posts }) => {
  return (
    <main className="Home">
        {posts.length ? (
            <Feed posts={posts} />
        ) : (
            <p style={{ marginTop: "2rem" }}>
                No posts to display.
            </p>
        )}
    </main>
  )
}

export default Home



remove all the <main> elements and start over in this file
    <main className="Home">
    </main>

then the first thing we do is
lets check if we have {isLoading}

    <main className="Home">
        {isLoading}
    </main>

if isLoading is true		&&
then we set <p> tag 
with a className="statusMsg"	v07.12.20
(we will define statusMsg shortly)
add isLoading					{isLoading
want &&						           &&    
add 2nd part of && which is the className	              <p className="statusMsg">
add <p> and text				                                       Loading posts...</p>
close }					  		                                                   }
so we have                                      {isLoading && <p className="statusMsg">Loading posts...</p>}

    <main className="Home">
        {isLoading && }
    </main>

    <main className="Home">
        {isLoading && <p className="statusMsg"}
    </main>

    <main className="Home">
        {isLoading && <p className="statusMsg">Loading</p>}
    </main>


summary

import Feed from './Feed';

const Home = ({ posts }) => {
  return (
    <main className="Home">
        {isLoading && <p className="statusMsg">Loading</p>}
        // fetchError code here
        // !isLoading && !fetchError code here
    </main>
  )
}

export default Home


so if isLoading is true then we are loading posts and we can show it this way

on the next line we check to see if we have a fetchError	        {fetchError}
add &&
add <p> tag with className="statusMsg"
but lets add a style right here and need {{}}
add color red b/c we know we have an error
and inside the paragraph, we can set the fetchError to display

        // fetcherror code here
        {fetchError}
        {fetchError && }
        {fetchError && <p className="statusMsg"}
        {fetchError && <p className="statusMsg" style={}}
        {fetchError && <p className="statusMsg" style={{color: "red"}}}
        {fetchError && <p className="statusMsg" style={{color: "red"}}>{}</p>}
        {fetchError && <p className="statusMsg" style={{color: "red"}}>{fetchError}</p>}

then we add one more line to show
and its not the isLoading or the fetchError message 
but to show the actual post 
(notice, easier to read this right to left for the objects)

now we want to show the post themselves 
and so we code this
if we do NOT have an isLoading message				{!isLoading }
&& we do NOT have a fetchError message				            && !fetchError}
&& posts.length using ternary statement
so if the posts.length
and here we add a ternary statement 
if <Feed posts={posts} then close out this component />
then add colon for false part
and this false part is a p tag with className statusMsg
then close this tag
and inside the paragraph text we add No posts to display.
add closing </p> tag
save

        {!isLoading }
        {!isLoading && }
        {!isLoading && !fetchError }
        {!isLoading && !fetchError && ()}
        {!isLoading && !fetchError && (posts.length)}
        {!isLoading && !fetchError && (posts.length ? )}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={} )}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={posts} )}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={posts} /> )}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={posts} /> : )}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={posts} /> : <p className="statusMsg"> )}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={posts} /> : <p className="statusMsg">No posts to display.</p>)}

so we save
reload app
we see the 2 second message showing text			Loading posts...
then we see the current posts

close Console
and reload app so see again			v07.14.41

so now we have Home.js

import Feed from './Feed';

const Home = ({ posts }) => {
  return (
    <main className="Home">
        {isLoading && <p className="statusMsg">Loading</p>}
        {fetchError && <p className="statusMsg" style={{color: "red"}}>{fetchError}</p>}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={posts} /> : <p className="statusMsg">No posts to display.</p>)}
    </main>
  )
}

export default Home


now lets go back to App.js
lets make an error on purpose so we know that our error message is also working  v07.15.05
add extra p
          ^
ie we create a problem with the url

  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');
  const { data, fetchError, isLoading } = useAxiosFetch('httpp://localhost:3500/posts');
							     ^
rendered Chrome app shows in red text

Network Error 

now reload
we see

Loading posts...
Network Error (in red)

then after 2 second we only see

Network Error (in red)

we we loading messge at the same time as error message (so lets change this)		v07.15.21

go back to the Home.js component

 

import Feed from './Feed';

const Home = ({ posts }) => {
  return (
    <main className="Home">
        {isLoading && <p className="statusMsg">Loading</p>}
        {fetchError && <p className="statusMsg" style={{color: "red"}}>{fetchError}</p>}
        {!isLoading && !fetchError && (posts.length ? <Feed posts={posts} /> : <p className="statusMsg">No posts to display.</p>)}
    </main>
  )
}

export default Home


lets change line 2 from	v			fetchError && p tag

to 				  !isLoading && fetchError && p tag

 
       {fetchError && <p className="statusMsg" style={{color: "red"}}>{fetchError}</p>}
       {!isLoading && fetchError && <p className="statusMsg" style={{color: "red"}}>{fetchError}</p>}

and change this from isLoading to !isLoading 
and yes fetchError
then save, reload

now when reloading the rendered app we see

Loading Error then Network Erro
yes this looks correct		v07.15.42

so lets go back to App.js and undo the intentional url error we put in earlier

  const { data, fetchError, isLoading } = useAxiosFetch('httpp://localhost:3500/posts');
  const { data, fetchError, isLoading } = useAxiosFetch('http://localhost:3500/posts');

now url is correct
save
reload app

now see 
Loading Posts
then we see the posts (so no Network error as url was fixed)

show file tree
go back to custom hook useAxiosFetch.js
hide file tree

lets get rid of the timeout		
delete setTimeout()			
then delete the 2000 
we know about the cleanUp function but we dont need the console.log so delete it
but since we are doing two things here (isMounted is false, and cancelling the source), 
so lets define it as cleanUp.
so now when we reload, we barely see the Loading Posts message at all 	v07.16.42



isMounted && setTimeout(() => setIsLoading(false), 2000);
isMounted && setIsLoading(false), 2000);
isMounted && setIsLoading(false);

	const cleanUp = () => {	
            console.log('clean up function')
            isMounted = false;
            source.cancel();
        }

	const cleanUp = () => {	
            isMounted = false;
            source.cancel(); 
        }


thus so far we have

import { useState, useEffect } from 'react'; 
import axios from 'axios';

const useAxiosFetch = (dataUrl) => {
    const [data, setData] = useState([]);
    const [fetchError, setFetchError] = useState(null);
    const [isLoading, setIsLoading] = useState(false);	

    useEffect(() => {
        let isMounted = true;
        const source = axios.CancelToken.source();

        const fetchData = async (url) => {
            setIsLoading(true);			
	    try{
                const response = await axios.get(url, {
                    cancelToken: source.token
                });
                if (isMounted) {
                    setData(response.data);
                    setFetchError(null);
                }
            } catch (err) {
                if (isMounted)
                    setFetchError(err.message);
                    setData([]);
            } finally {
                isMounted && setIsLoading(false));			<<<<<<<<<<HERE
            }
        }

        fetchData(dataUrl);

	const cleanUp = () => {						<<<<<<<<<<<
            isMounted = false;					
            source.cancel();
        }

       return cleanUp;
    }, [dataUrl]);

    return { data, fetchError, isLoading }; 

}

export default useAxiosFetch;


summary 
v07.16.44 
so we have created two custom hooks today useAxiosFetch and useWindowSize
we might find different versions of these two functions on the web as
they have different authors 
use them like recipes or utility functions as you can pull them 
into different projects over and over.
Remember the rules for hooks

// Next Chapt 21 Content API preview

DataContext.js

import { createContext, useState, useEffect } from 'react';
import { Route, Switch, useHistory } from 'react-router'dom';
import { useState, useEffect } from 'react';
import { format } from 'date-fns';				
import api from './api/posts';					
import useWindowSize from './hooks/useWindowSize';		
import useAxiosFetch from './hooks/useAxiosFetch';		

const DataContext = createContext({});

export const DataProvider = ({ children }) => {
    return (
        <DataContent.Provider value={{
	    // add data feeds here - tbd
	    // add data feeds here - tbd
	    // add data feeds here - tbd
        }}>
            {children}
        </DataContext.Provider>
    )
}

export default DataContext;



